package rice.p2p.saar.simulation;

import rice.p2p.saar.*;
import java.io.*;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.util.Iterator;
import java.util.Vector;
import java.util.Hashtable;
import java.util.Random;

import rice.environment.Environment;
import rice.p2p.commonapi.Id;
import rice.pastry.NodeHandle;
import rice.pastry.NodeIdFactory;
import rice.pastry.PastryNode;
import rice.pastry.PastryNodeFactory;
import rice.pastry.direct.*;
import rice.pastry.leafset.LeafSet;
import rice.pastry.standard.RandomNodeIdFactory;

public class SaarSimTest {


    public static boolean CENTRALIZEDSCRIBE = false;  //p2p.saar.SaarImpl/p2p.saar.SaarPolicy uses this flag

    public static String MATRIXFILE = "/DS/usr/animesh/anycast/King_Modelnet.500";

    // this will keep track of our applications
    Vector apps = new Vector();

    Vector nodes = new Vector(); 
    
    protected Environment env;

    public static int NUMNODES = 1;

    //public static int simulatorbroadcastseqnum = -1; // This is a temporrary hack for the simulator version to know the global broadcast sequnce number, in a decentralized environment it will use the grpSummary() code to set this value based on downward propagates in the saar tree

    public static int foregroundBroadcastSeqnum = -1; 

    public static int backgroundBroadcastSeqnum = -1; 



    public Random rng = new Random(); 



    //public Hashtable grpSummaryMetadata = new Hashtable(); // this is a temporary hack to see the best possible scenario of the multitree with respect to reducing the join delay problem because of waiting for the grpSummary to arrive via the control plane

    /**
     * This constructor launches numNodes PastryNodes.  They will bootstrap 
     * to an existing ring if one exists at the specified location, otherwise
     * it will start a new ring.
     * 
     * @param bindport the local port to bind to 
     * @param bootaddress the IP:port of the node to boot from
     * @param numNodes the number of nodes to create in this JVM
     * @param env the environment for these nodes
     */
    public SaarSimTest(int numNodes, Environment env) throws Exception {

	this.env = env;

	
	


	rice.p2p.saar.SaarClient.MULTICASTSOURCEBINDINDEX = 1;
	

	// We will print out the importtant configurations
	System.out.println("");
	System.out.println("SAAR-CONFIGS");
	System.out.println("************");
	System.out.println("NUMNODES: " + numNodes);
	System.out.println("CENTRALIZEDSCRIBE: " + CENTRALIZEDSCRIBE);
	System.out.println("pastry.direct.GenericNetwork.DELAYTOCENTRALIZEDSERVER: " + rice.pastry.direct.GenericNetwork.DELAYTOCENTRALIZEDSERVER);
	System.out.println("p2p.saar.SaarClient.DATAPLANETYPE: " + SaarClient.DATAPLANETYPE);
	System.out.println("p2p.saar.SaarTopic.NUMTREES: " + SaarTopic.NUMTREES);
	System.out.println("p2p.saar.SaarClient.CONTROLOVERLAYBOOTTIME: " + SaarClient.CONTROLOVERLAYBOOTTIME);
	System.out.println("p2p.saar.SaarClient.MAXINITIALWAITTIME: " + SaarClient.MAXINITIALWAITTIME);
	System.out.println("p2p.saar.SaarClient.EXPONENTIALOFFLINE: " + SaarClient.EXPONENTIALOFFLINE);
	System.out.println("p2p.saar.SaarClient.OFFLINETIME: " + SaarClient.OFFLINETIME);
	System.out.println("p2p.saar.SaarClient.NOCHURNTIME: " + SaarClient.NOCHURNTIME);
	System.out.println("p2p.saar.SaarClient.MEANDATAOVERLAYCHURNPERIOD: " + SaarClient.MEANDATAOVERLAYCHURNPERIOD);
	System.out.println("p2p.saar.SaarClient.MINIMUMDATAOVERLAYSTAYTIME: " + SaarClient.MINIMUMDATAOVERLAYSTAYTIME);
	System.out.println("p2p.saar.SaarClient.EXPERIMENTTIME: " + SaarClient.EXPERIMENTTIME);
	System.out.println("p2p.saar.SaarClient.DATAOVERLAYCHURNTYPE: " + SaarClient.DATAOVERLAYCHURNTYPE);
	System.out.println("p2p.saar.SaarClient.MUL: " + SaarClient.MUL);	  
	System.out.println("p2p.saar.SaarClient.HETEROGENOUSTYPE: " + SaarClient.HETEROGENOUSTYPE);
	System.out.println("p2p.saar.SaarClient.MINDEGREE: " + SaarClient.MINDEGREE);
	System.out.println("p2p.saar.SaarClient.DEGREECAP: " + SaarClient.DEGREECAP);
	System.out.println("p2p.saar.SaarClient.SOURCEDEGREE: " + SaarClient.SOURCEDEGREE);
	System.out.println("p2p.saar.blockbased.CoolstreamingBufferMap.ADVERTISEDWINDOWSIZE: " + rice.p2p.saar.blockbased.CoolstreamingBufferMap.ADVERTISEDWINDOWSIZE);
	System.out.println("p2p.saar.blockbased.CoolstreamingBufferMap.FETCHWINDOWSIZE: " + rice.p2p.saar.blockbased.CoolstreamingBufferMap.FETCHWINDOWSIZE);
	System.out.println("p2p.saar.blockbased.BlockbasedClient.COOLSTREAMINGCONFIG: " + rice.p2p.saar.blockbased.BlockbasedClient.COOLSTREAMINGCONFIG);
	System.out.println("p2p.saar.multitree.MultitreeClient.SPLITSTREAMCONFIG: " + rice.p2p.saar.multitree.MultitreeClient.SPLITSTREAMCONFIG);
	System.out.println("p2p.saar.SaarClient.MULTICASTSOURCEBINDINDEX: " + rice.p2p.saar.SaarClient.MULTICASTSOURCEBINDINDEX);
	System.out.println("p2p.saar.singletree.SingletreeClient.PUBLISHPERIOD: " + rice.p2p.saar.singletree.SingletreeClient.PUBLISHPERIOD);
	System.out.println("p2p.saar.multitree.MultitreeClient.PUBLISHPERIOD: " + rice.p2p.saar.multitree.MultitreeClient.PUBLISHPERIOD);
	System.out.println("p2p.saar.blockbased.BlockbasedClient.PUBLISHPERIOD: " + rice.p2p.saar.blockbased.BlockbasedClient.PUBLISHPERIOD);

	System.out.println("p2p.saar.multitree.SingletreeClient.NUMSTRIPES: " + rice.p2p.saar.singletree.SingletreeClient.NUMSTRIPES);
	System.out.println("p2p.saar.multitree.MultitreeClient.NUMSTRIPES: " + rice.p2p.saar.multitree.MultitreeClient.NUMSTRIPES);
	System.out.println("p2p.saar.blockbased.BlockbasedClient.ACQUIREDTHRESHOLD: " + rice.p2p.saar.blockbased.BlockbasedClient.ACQUIREDTHRESHOLD);
	System.out.println("p2p.saar.singletree.SingletreeClient.STRIPEINTERVALPERIOD: " + rice.p2p.saar.singletree.SingletreeClient.STRIPEINTERVALPERIOD);
	System.out.println("pastry.direct.GenericNetwork.delayFactor: " + rice.pastry.direct.GenericNetwork.delayFactor);
	//System.out.println("p2p.saar.SaarClient.DATAPLANEMAINTENANCEPERIOD: " + rice.p2p.saar.SaarClient.DATAPLANEMAINTENANCEPERIOD);
	System.out.println("p2p.saar.SaarClient.CONTROLPLANEUPDATEPERIOD: " + rice.p2p.saar.SaarClient.CONTROLPLANEUPDATEPERIOD);
	System.out.println("p2p.saar.SaarClient.VIRTUALSOURCEMAXBINDINDEX: " + rice.p2p.saar.SaarClient.VIRTUALSOURCEMAXBINDINDEX);
	System.out.println("p2p.saar.singletree.SingletreeClient.NUMPRMNEIGHBORS: " + rice.p2p.saar.singletree.SingletreeClient.NUMPRMNEIGHBORS);
	System.out.println("p2p.saar.singletree.SingletreeClient.PRMBETA: " + rice.p2p.saar.singletree.SingletreeClient.PRMBETA);
	System.out.println("p2p.saar.singletree.SingletreeClient.ENABLEPRM: " + rice.p2p.saar.singletree.SingletreeClient.ENABLEPRM);
	System.out.println("p2p.saar.singletree.SaarClient.LINKLOSSPROBABILITY: " + rice.p2p.saar.SaarClient.LINKLOSSPROBABILITY);
	System.out.println("p2p.saar.multitree.MultitreeClient.NUMREDUNDANTSTRIPES: " + rice.p2p.saar.multitree.MultitreeClient.NUMREDUNDANTSTRIPES);
	System.out.println("p2p.saar.blockbased.BlockbasedClient.ADVERTISINGPERIOD: " + rice.p2p.saar.blockbased.BlockbasedClient.ADVERTISINGPERIOD);
	System.out.println("p2p.saar.blockbased.BlockbasedClient.M: " + rice.p2p.saar.blockbased.BlockbasedClient.M);
	System.out.println("p2p.saar.blockbased.BlockbasedClient.RIINDEPENDENTOUTDEGREE: " + rice.p2p.saar.blockbased.BlockbasedClient.RIINDEPENDENTOUTDEGREE);
	System.out.println("p2p.saar.blockbased.BlockbasedClient.UNSYNCHRONIZEDWINDOW: " + rice.p2p.saar.blockbased.BlockbasedClient.UNSYNCHRONIZEDWINDOW);	
	System.out.println("p2p.saar.multitree.MultitreeClient.ENABLESIMULATORGRPSUMMARY: " + rice.p2p.saar.multitree.MultitreeClient.ENABLESIMULATORGRPSUMMARY);
	System.out.println("p2p.saar.blockbased.BlockbasedClient.DOFINEGRAINEDADVERTISING: " + rice.p2p.saar.blockbased.BlockbasedClient.DOFINEGRAINEDADVERTISING);	
	System.out.println("p2p.saar.blockbased.BlockbasedClient.DAMPENREQUESTBLOCKSMSG: " + rice.p2p.saar.blockbased.BlockbasedClient.DAMPENREQUESTBLOCKSMSG);	
	System.out.println("p2p.saar.blockbased.BlockbasedClient.STALEBMAPTHRESHOLD: " + rice.p2p.saar.blockbased.BlockbasedClient.STALEBMAPTHRESHOLD);	
	System.out.println("p2p.saar.SaarClient.HYBRIDDEBUG: " + rice.p2p.saar.SaarClient.HYBRIDDEBUG);


	
	// Generate the NodeIds Randomly
	NodeIdFactory nidFactory = new RandomNodeIdFactory(env);
    
	// construct the PastryNodeFactory, this is how we use rice.pastry.direct, with a Euclidean Network
	//NetworkSimulator ns = new SphereNetwork(env);
	//NetworkSimulator ns = new EuclideanNetwork(env);
	
	//NetworkSimulator ns = new GenericNetwork(env, new File("/DS/usr/animesh/anycast/King_Modelnet.500"));
	NetworkSimulator ns = new GenericNetwork(env, new File(MATRIXFILE));
	
	SimulatorListener simlistener = new SaarSimulatorListener(env);
	ns.addSimulatorListener(simlistener);

	ns.setMaxSpeed((float)1.0);
	PastryNodeFactory factory = new DirectPastryNodeFactory(nidFactory, ns, env);
	
	// create the handle to boot off of
	NodeHandle bootHandle = null;
	NodeHandle centralizedHandle = null;

	// loop to construct the nodes
	for (int curNode = 0; curNode < numNodes; curNode++) {

	    ns.setMaxSpeed(curNode+1);

	    System.out.println("curNode: " + curNode);
	    // construct a node, passing the null boothandle on the first loop will cause the node to start its own ring
	    PastryNode node = factory.newNode(bootHandle);

	    

	    // this way we can boot off the previous node
	    bootHandle = node.getLocalHandle();

	    // The centralizedHandle remains null when CENTRALIZEDSCRIBE= false
	    if(CENTRALIZEDSCRIBE && (curNode == 0)) {
		centralizedHandle = bootHandle;
		System.out.println("CentralizedHandle: " + centralizedHandle);

	    }
	    
	    System.out.println("after bootHandle");
	    // the node may require sending several messages to fully boot into the ring
	    synchronized(node) {
		while(!node.isReady() && !node.joinFailed()) {
		    System.out.println("in loop");
		    // delay so we don't busy-wait
		    node.wait(500);
		    
		    // abort if can't join
		    if (node.joinFailed()) {
			throw new IOException("Could not join the FreePastry ring.  Reason:"+node.joinFailedReason()); 
		    }
		}       
	    }
	    nodes.add(node);
	    System.out.println("Finished creating new node[" + curNode + "] " + node);
	}

	ns.setMaxSpeed(1.0f);


	Vector nodedegrees = new Vector();
	// We will first get all the nodedegrees
	for (int curNode = 0; curNode < numNodes; curNode++) {
	    double nodedegree = SaarClient.getNodedegree(rng);
	    nodedegrees.add(new Double(nodedegree));
	}
	// We will sort the node degrees
	Vector sortedNodedegrees = new Vector();
	// We will first add the centralized server degree
	sortedNodedegrees.add(new Double(SaarClient.CENTRALSERVERDEGREE));
	// We will first add the source degree
	sortedNodedegrees.add(new Double(SaarClient.SOURCEDEGREE));

	double chosenNodedegree = 0;
	while(!nodedegrees.isEmpty()) {
	    double nodedegree;
	    nodedegree = ((Double)nodedegrees.elementAt(0)).doubleValue();
	    chosenNodedegree = nodedegree;
	    
	    for(int index = 1; index < nodedegrees.size(); index++) {
		nodedegree = ((Double)nodedegrees.elementAt(index)).intValue();
		if(nodedegree > chosenNodedegree) {
		    chosenNodedegree = nodedegree;
		}
	    }
	    sortedNodedegrees.add(new Double(chosenNodedegree));
	    nodedegrees.remove(new Double(chosenNodedegree));
	}
	// Since we initially added the CENTRALSERVERDEGREE/SOURCEDEGREE, we will remove the last member from the sorted list
	sortedNodedegrees.remove(sortedNodedegrees.size()-1);

	sortedNodedegrees.remove(sortedNodedegrees.size()-1);

	if(sortedNodedegrees.size() != numNodes) {
	    System.out.println("The number of entries in the sorted nodedegrees is not equal to the overlay size");
	    System.exit(1);
	}


	// We assumed above that the {centralserver had index = 0, multicast source had index = 1}



	// loop to attach apps to nodes
	for (int curNode = 0; curNode < numNodes; curNode++) {
	    PastryNode node = (PastryNode)nodes.elementAt(curNode);
	    int BINDINDEX = curNode;
	    int JVMINDEX = 0;
	    int VINDEX = 0;
	    int SESSIONTIME = 3000;
	    long BOOTTIME = env.getTimeSource().currentTimeMillis();
	    boolean amMulticastSource = false;
	    boolean amVirtualSource = false;

	    double nodedegree = ((Double)sortedNodedegrees.remove(0)).doubleValue();


	    if(BINDINDEX == SaarClient.MULTICASTSOURCEBINDINDEX) {
		amMulticastSource = true;

	    } else if((BINDINDEX > SaarClient.MULTICASTSOURCEBINDINDEX) && (BINDINDEX <= SaarClient.VIRTUALSOURCEMAXBINDINDEX)) {
	    
		amVirtualSource = true;
		
	    } else {
		// Centralized node (index=0) or other normal nodes
	    }
	    
	    SaarClient app = new SaarClient(BINDINDEX, JVMINDEX,  VINDEX, node, null, null, factory, "saarClient", SESSIONTIME, BOOTTIME, centralizedHandle, nodedegree, amMulticastSource, amVirtualSource, this);
	    apps.add(app);
	    System.out.println("Finished attaching application[" + curNode + "] " + node);
	}

	ns.setFullSpeed();	


	
	// wait 10 seconds
	env.getTimeSource().sleep(10000);
	
	
    }

    



    /**
     * Usage: 
     * java [-cp FreePastry-<version>.jar] rice.tutorial.direct.DirectTutorial numNodes
     * example java rice.tutorial.direct.DirectTutorial 100
     */
    public static void main(String[] args) throws Exception {
	// Loads pastry settings, and sets up the Environment for simulation
	Environment env = Environment.directEnvironment();

	env.getParameters().setBoolean("environment_logToFile", true);


	// We do the parsing of the options
	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-help")) {
		System.out.println("Usage: SaarSimTest -nodes -dataplanetype -iscentralized -delaytocentralserver -matrixfile");
		System.exit(1);
	    }
	}


	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-nodes") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    NUMNODES = n;
	      } 
		break;
	    }
	}



	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-virtualsourcemaxbindindex") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    System.out.println("Setting virtualsourcemaxbindindex= " + n);
		    SaarClient.VIRTUALSOURCEMAXBINDINDEX = n;
		} 
		break;
	    }
	}


	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-dataplanetype") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    SaarClient.DATAPLANETYPE= n;
		    
	      } 
		break;
	    }
	}



	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-meanstaytime") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    SaarClient.MEANDATAOVERLAYCHURNPERIOD = n;
		    
	      } 
		break;
	    }
	}

	
	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-minimumstaytime") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    SaarClient.MINIMUMDATAOVERLAYSTAYTIME = n;
		    
	      } 
		break;
	    }
	}


	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-degreedist") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    SaarClient.HETEROGENOUSTYPE = n;
		    
	      } 
		break;
	    }
	}

	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-mul") && i + 1 < args.length) {
		float n = Float.parseFloat(args[i + 1]);
		if(n>=0) {
		    SaarClient.MUL = (double)n;
		    
	      } 
		break;
	    }
	}


	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-mindegree") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    SaarClient.MINDEGREE = n;
		    
	      } 
		break;
	    }
	}



	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-degreecap") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    SaarClient.DEGREECAP = n;
		    
	      } 
		break;
	    }
	}


	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-sourcedegree") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    SaarClient.SOURCEDEGREE = n;
		    
	      } 
		break;
	    }
	}

	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-numneighbors") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    rice.p2p.saar.blockbased.BlockbasedClient.M = n;
		    
	      } 
		break;
	    }
	}


	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-advertisedwindowsize") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    rice.p2p.saar.blockbased.CoolstreamingBufferMap.ADVERTISEDWINDOWSIZE = n;
		    
	      } 
		break;
	    }
	}



	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-fetchwindowsize") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    rice.p2p.saar.blockbased.CoolstreamingBufferMap.FETCHWINDOWSIZE = n;
		    
	      } 
		break;
	    }
	}


	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-networkdelayfactor") && i + 1 < args.length) {
		float n = Float.parseFloat(args[i + 1]);
		if(n>=0) {
		    rice.pastry.direct.GenericNetwork.delayFactor = n;
		    
		} 
		break;
	    }
	}


	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-prmbeta") && i + 1 < args.length) {
		float n = Float.parseFloat(args[i + 1]);
		if(n>=0) {
		    rice.p2p.saar.singletree.SingletreeClient.PRMBETA  = (double) n;
		    
		} 
		break;
	    }
	}

	
	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-linkloss") && i + 1 < args.length) {
		float n = Float.parseFloat(args[i + 1]);
		if(n>=0) {
		    rice.p2p.saar.SaarClient.LINKLOSSPROBABILITY  = (double) n;
		    
		} 
		break;
	    }
	}

	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-numstripes") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    rice.p2p.saar.singletree.SingletreeClient.NUMSTRIPES = n;
		    rice.p2p.saar.multitree.MultitreeClient.NUMSTRIPES = n;
		    
	      } 
		break;
	    }
	}

	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-stripeintervalperiod") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    rice.p2p.saar.singletree.SingletreeClient.STRIPEINTERVALPERIOD = n;        // ms
		    
	      } 
		break;
	    }
	}



	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-publishperiod") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    rice.p2p.saar.singletree.SingletreeClient.PUBLISHPERIOD = n;        // ms
		    rice.p2p.saar.multitree.MultitreeClient.PUBLISHPERIOD = n;        // ms
		    rice.p2p.saar.blockbased.BlockbasedClient.PUBLISHPERIOD = n; // ms
		    
		} 
		break;
	    }
	}


	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-advertisingperiod") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    rice.p2p.saar.blockbased.BlockbasedClient.ADVERTISINGPERIOD = n; // ms
		    
	      } 
		break;
	    }
	}

	// We now use the SaarClient.PUBLISHPERIOD to also determine the frequency of scheduling of dataplaneMaintenance()
	//for (int i = 0; i < args.length; i++) {
	//  if (args[i].equals("-dataplanemaintenanceperiod") && i + 1 < args.length) {
	//int n = Integer.parseInt(args[i + 1]);
	//if(n>=0) {
	//    rice.p2p.saar.SaarClient.DATAPLANEMAINTENANCEPERIOD  = n;        // ms
	//    
	//} 
	//break;
	//  }
	//}

	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-controlplaneupdateperiod") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    rice.p2p.saar.SaarClient.CONTROLPLANEUPDATEPERIOD  = n;        // ms
		    
		} 
		break;
	    }
	}


	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-stalebmapthreshold") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    rice.p2p.saar.blockbased.BlockbasedClient.STALEBMAPTHRESHOLD  = n;        // ms
		    
		} 
		break;
	    }
	}



	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-blockbasedneighborrefresh") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    rice.p2p.saar.blockbased.BlockbasedClient.ACQUIREDTHRESHOLD = n;        // ms
		    
		} 
		break;
	    }
	}


	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-nochurntime") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    rice.p2p.saar.SaarClient.NOCHURNTIME = n;        // ms
		    
		} 
		break;
	    }
	}



	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-delaytocentralserver") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>=0) {
		    GenericNetwork.DELAYTOCENTRALIZEDSERVER = n;
		} 
		break;
	    }
	}
	


	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-iscentralized") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>0) {
		    CENTRALIZEDSCRIBE = true;
		} 
		break;
	    }
	}

	//for (int i = 0; i < args.length; i++) {
	//  if (args[i].equals("-simulatorgrpsummary") && i + 1 < args.length) {
	//int n = Integer.parseInt(args[i + 1]);
	//if(n>0) {
	//    rice.p2p.saar.multitree.MultitreeClient.ENABLESIMULATORGRPSUMMARY = true;
	//} 
	//break;
	//  }
	//}

	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-splitstreamconfig") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>0) {
		    rice.p2p.saar.multitree.MultitreeClient.SPLITSTREAMCONFIG = true;
		} 
		break;
	    }
	}



	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-hybriddebug") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>0) {
		    rice.p2p.saar.SaarClient.HYBRIDDEBUG = true;
		} 
		break;
	    }
	}






	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-dampenrequestblocksmsg") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>0) {
		    rice.p2p.saar.blockbased.BlockbasedClient.DAMPENREQUESTBLOCKSMSG = true;
		} 
		break;
	    }
	}


	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-unsynchronizedwindow") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>0) {
		    rice.p2p.saar.blockbased.BlockbasedClient.UNSYNCHRONIZEDWINDOW = true;
		} 
		break;
	    }
	}





	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-primaryreconstruction") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>0) {
		    rice.p2p.saar.multitree.MultitreeClient.ENABLEPRIMARYFRAGMENTRECONSTRUCTION = true;
		} 
		break;
	    }
	}


	
	//for (int i = 0; i < args.length; i++) {
	//  if (args[i].equals("-bandwidthstaging") && i + 1 < args.length) {
	//int n = Integer.parseInt(args[i + 1]);
	//if(n>0) {
	//    rice.p2p.saar.singletree.SingletreeClient.BANDWIDTHSTAGING = true;
	//} 
	//break;
	//  }
	//}


	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-riindependentoutdegree") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>0) {
		    rice.p2p.saar.blockbased.BlockbasedClient.RIINDEPENDENTOUTDEGREE = true;
		} 
		break;
	    }
	}


	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-dofinegrainedadvertising") && i + 1 < args.length) {
		int n = Integer.parseInt(args[i + 1]);
		if(n>0) {
		    rice.p2p.saar.blockbased.BlockbasedClient.DOFINEGRAINEDADVERTISING = true;
		} 
		break;
	    }
	}
	

	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-matrixfile") && i + 1 < args.length) {
		MATRIXFILE = args[i + 1];
		
	     
		break;
	    }
	}




    
	try {
	    SaarSimTest st = new SaarSimTest(NUMNODES, env);
	} catch (Exception e) {
	    // remind user how to use
	    System.out.println("Usage:"); 
	    System.out.println("java [-cp FreePastry-<version>.jar] rice.p2p.saar.simulation.SaarSimTest numNodes");
	    throw e; 
	}
    }
}
