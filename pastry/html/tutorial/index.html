<html><head>
  <title>FreePastry Tutorial</title>
  <link rel="stylesheet" href="tutorial.css" />
</head>
<body>

<div class="content">
<div class="frontmatter">

<h1>The FreePastry Tutorial.</h1>

<div class="abstract">This tutorial is designed to get you cooking quickly with the FreePastry
API and software toolkit.</div>

<h4>Version 1.2; May 26, 2005.  For <a
href="http://freepastry.rice.edu/">FreePastry</a> version 1.4.1.  Maintained by <a
href="mailto:jeffh@rice.edu">Jeff Hoye</a>.</h4>

</div>

<h2>Contents</h2>
<ul>
	<h3>Getting Started</h3>
	<ul>
	<li><a href="#requirements">What You'll Need</a></li>
	</ul>
	<h3>Lessons</h3>
	<ul>
	<li><a href="#lesson1">Lesson 1</a>: Minimal code to create/join a pastry
	ring.</li>
	<li><a href="#lesson2">Lesson 2</a>: Execute the code to launch your new
	ring.</li>
	<li><a href="#lesson3">Lesson 3</a>: Write a simple application using the
	commonAPI. (this will show you how to send and receive messages)</li>
	<li><a href="#lesson4">Lesson 4</a>: Running multiple nodes in the same 
	JVM.</li>
	<li><a href="#lesson5">Lesson 5</a>: Scheduling tasks on the FreePastry 
	timer.</li>
	<li><a href="#lesson6">Lesson 6</a>: Introducing Scribe.</li>
	</ul>
	<h3>Coming soon:</h3>
	<ul>
	<li>Lesson 7: Advanced Scribe: Policies.</li>
	<li>Lesson 8: Past.</li>
	<li>Lesson 9: Splitstream.</li>
	</ul>
</ul>

<hr/>

<a name="requirements"></a><h2>What You'll Need</h2>
Before you begin, you should meet the following requirements.  
<ol>
  <li>An intermediate level of knowledge in the Java programming language.  <a href="http://java.sun.com/docs/books/tutorial/">The Java Tutorial</a> is a good place to start. 
  <li>A copy of a current JDK, 1.4.2_06 or later.  <a href="http://java.sun.com/j2se/index.jsp">Sun's J2SE</a>. 
  <li>A basic understanding of Pastry overlay structure.  Read the short overview <a href="http://freepastry.rice.edu/PAST/overview.pdf">[pdf]</a><a href="http://freepastry.rice.edu/PAST/overview.ps">[ps]</a> of <a href="http://freepastry.rice.edu/">FreePastry</a>.
  <li>Have a working copy of FreePastry-1.4_01 or later.  You can simply download the <a href="http://freepastry.rice.edu/FreePastry/FreePastry-1.4.1.jar">current jar</a>, or download and build the <a href="http://freepastry.rice.edu/FreePastry/">source</a>.
</ol>
<hr/>

<a name="lesson1"></a><h1>Lesson 1</h1>
<h2>Minimal code to create/join a pastry ring.</h2>

<h3>Download the tutorial file <a href="./src/lesson1/DistTutorial.java">DistTutorial.java</a>.</h3>

In this lesson we are going to use Socket transport layer to communicate.  The Socket transport layer is a package within the pastry source tree that is used to communicate between nodes using Internet Protocol (IP).  It is located in rice.pastry.socket.  Socket uses TCP for all messages except liveness which it uses UDP to accomplish.  Before we dive into the code lets start with a short vocabulary lesson:<br>

<h2>Terms:</h2>
<ul>
  <li><b>NodeId</b>&mdash;The randomly assigned unique identifier of a Node in the FreePastry.  <i>Typically a NodeId is 160bit represented by 20 Hex digits.  We usually only display the first 6 digits as this is enough to uniquely identify nodes for a pretty large ring.</i></li>
  <li><b>NodeIdFactory</b>&mdash;This generates your local NodeId.  <i>Why do we need a NodeIdFactory?  In a real deployment of Pastry, it is critical that one cannot choose their NodeId.  To accomplish this you may want to use a Certificate Authority to centrally assign NodeIds.  However, for your initial purposes one doesn't need to be able to secure the choice of NodeId.  The factory pattern gives us the flexibility we need to change this behavior in the future.  Thus we begin with RandomNodeIdFactory which generates a Random node id.</i></li>
  <li><b>PastryNode</b>&mdash;This is a Node in the network.  <i>Your application will send messages through the node and the node will deliver messages to your application.</i></li>
  <li><b>NodeHandle</b>&mdash;This is a "reference" to a PastryNode.  It is how you refer to a specific node in the network.  <i>A NodeHandle consists of a NodeId and whatever information the transport layer needs to find the node in the underlieing protocol.  In this case an IP address and port.  In this lesson, you will use a NodeHandle to bootstrap your node into the ring.  You can get the NodeHandle to your local node by calling PastryNode.getLocalHandle().  In the distributed environment, you will need to get a NodeHandle to your bootstrap node(s) by asking the transport layer.  In this case you are interested in acquiring a node handle from an IP address and port.  The the Socket transport uses this information to opens a socket to this address:port and requests a copy of the NodeHandle from the remote node.  If it doesn't find a node at this location it returns null.</i></li>
  <li><b>Bootstrap Node</b>&mdash;The node you use to join the ring.  <i>When a node starts up, it can either join an existing ring, or start a new one.  If you don't have a ring yet, then your choice is narrowed down to starting your own.  But once your first node has started a ring, you probably want all new nodes join that one.  To join a ring, you need to bootstrap off of any one node in the existing ring.  This is the bootstrap node.  In the example below, we use the first node that we construct as the bootstrap node.  In a real deployment, you may want to cache several nodes so that if you are unable to boot off of the first one, you can try others.</i></li>
  <li><b>PastryNodeFactory</b>&mdash;Constructs and initializes the Pastry Node.  <i>This sets up the PastryNode including the transport layer, the Leafset Maintenance protocol and, the RoutingTable Maintenance protocol.  These protocols are necessary for a FreePastry deployment to properly maintain the overlay structure.  In this example we will use the SocketPastryNodeFactory which as its name implies sets up the pastry node to use the Socket transport layer to communicate with other nodes.</i></li>  
</ul>

<p/>Now that you have the proper vocabulary, here is the constructor for the DistTutorial.  You can see most of the elements described in the vocabulary.

<pre>
  /**
   * This constructor sets up a PastryNode.  It will bootstrap to an 
   * existing ring if it can find one at the specified location, otherwise
   * it will start a new ring.
   * 
   * @param bindport the local port to bind to 
   * @param bootaddress the IP:port of the node to boot from
   */
  public DistTutorial(int bindport, InetSocketAddress bootaddress) throws Exception {
    
    // Used to generate the NodeIds Randomly
    NodeIdFactory nidFactory = new RandomNodeIdFactory();
    
    // construct the PastryNodeFactory, this is how we use rice.pastry.socket
    PastryNodeFactory factory = new SocketPastryNodeFactory(nidFactory, bindport);

    // This will return null if we there is no node at that location
    NodeHandle bootHandle = ((SocketPastryNodeFactory)factory).getNodeHandle(bootaddress);
      
    // construct a node, passing the null boothandle on the first loop will 
    // cause the node to start its own ring
    PastryNode node = factory.newNode(bootHandle);
      
    // the node may require sending several messages to fully boot into the ring
    while(!node.isReady()) {
      // delay so we don't busy-wait
      Thread.sleep(100);
    }
    
    System.out.println("Finished creating new node "+node);
  }
</pre>

<h3>Let's examine each line:</h3>

<ol>
  <li>The arguments that we start with are: 
  <ol type="a">
    <li><code>int bindport</code>&mdash;the local port to bind to.</li>
    <li><code>InetSocketAddress bootaddress</code>&mdash;The address of our bootstrap node.</li>
  </ol><br/>
<pre>
public DistTutorial(int bindport, InetSocketAddress bootaddress) throws Exception {</pre></li>

  <li>We begin by constructing our NodeIdFactory, which we are going to need to give to our PastryNodeFactory.<br/><br/>
<pre>
NodeIdFactory nidFactory = new RandomNodeIdFactory();</pre></li>

  <li>Give the nidFactory to our SocketPastryNodeFactory.  Additionally, we need to tell the SocketPastryNodeFactory what port to bind our pastry node to.<br/><br/>
<pre>
PastryNodeFactory factory = new SocketPastryNodeFactory(nidFactory, bindport);</pre></li>

  <li>Turn the bootaddress into a NodeHandle.  Note that this call blocks, and can take several seconds to complete.  It is opening a socket to the specified address.  If there is an error, or no PastryNode found at the bootaddress, then <code>getNodeHandle()</code> returns null.<br/><br/>
<pre>
NodeHandle bootHandle = ((SocketPastryNodeFactory)factory).getNodeHandle(bootaddress);</pre></li>

  <li>Finally, create the PastryNode.  If bootHandle is null then the factory will start a new ring.<br/><br/>
<pre>
PastryNode node = factory.newNode(bootHandle);</pre></li>

  <li>Even though we don't have an application to run yet, it is important that you are aware of the call to <code>PastryNode.isReady()</code>.  This method returns false until the node is fully booted into the ring (which entails establishing his neighbor set i.e. the routing table and the leafset).  This simple loop is a typical way to wait for the node to fully boot into the ring.<br/>
<pre>
while(!node.isReady()) {
  Thread.sleep(100);
}
</pre></li>
</ol>

<p/>Before we can run our program lets take a quick look at the <code>main()</code> method.  We need to get 1) the local port to bind to, 2) the IP address of the bootstrap node, and 3) the port of the bootstrap node.

<pre>
  /**
   * Usage: 
   * java [-cp FreePastry-<version>.jar] rice.tutorial.lesson1.DistTutorial localbindport bootIP bootPort
   * example java rice.tutorial.DistTutorial 9001 pokey.cs.almamater.edu 9001
   */
  public static void main(String[] args) throws Exception {
    try {
      // the port to use locally
      int bindport = Integer.parseInt(args[0]);
      
      // build the bootaddress from the command line args
      InetAddress bootaddr = InetAddress.getByName(args[1]);
      int bootport = Integer.parseInt(args[2]);
      InetSocketAddress bootaddress = new InetSocketAddress(bootaddr,bootport);
  
      // launch our node!
      DistTutorial dt = new DistTutorial(bindport, bootaddress);
    } catch (Exception e) {
      // remind user how to use
      System.out.println("Usage:"); 
      System.out.println("java [-cp FreePastry-<version>.jar] rice.tutorial.lesson1.DistTutorial localbindport bootIP bootPort");
      System.out.println("example java rice.tutorial.DistTutorial 9001 pokey.cs.almamater.edu 9001");
      throw e; 
    } 
  }
</pre>    

<h3>Let's examine each line:</h3>

<ol>
  <li>This line parses the first command line argument into an int.
<pre>
int bindport = Integer.parseInt(args[0]);
</pre></li>

  <li>These lines parse the IP and port and turn them into an InetSocketAddress.
<pre>
InetAddress bootaddr = InetAddress.getByName(args[1]);
int bootport = Integer.parseInt(args[2]);
InetSocketAddress bootaddress = new InetSocketAddress(bootaddr,bootport);
</pre></li>
  <li>Finally we execute our constructor.
<pre>
DistTutorial dt = new DistTutorial(bindport, bootaddress);
</pre></li>
  <li>We wrap the method with an indication of how to use the program in case the user inputs the wrong args.
<pre>
    try {

      ...
      
    } catch (Exception e) {
      // remind user how to use
      System.out.println("Usage:"); 
      System.out.println("java [-cp FreePastry-<version>.jar] rice.tutorial.lesson1.DistTutorial localbindport bootIP bootPort");
      System.out.println("example java rice.tutorial.DistTutorial 9001 pokey.cs.almamater.edu 9001");
      throw e; 
    } 
</pre></li>
</ol>

<h3>Congratulations!  You have built code to launch/join a FreePastry ring!<br>
Lesson 2 will aid you in running your code.</h3>

<hr/>

<a name="lesson2"></a><h1>Lesson 2</h1>
<h2>Execute the code to launch your new ring.</h2>

<p/>This is a short lesson that shows you how to run <a href="./src/lesson1/DistTutorial.java">DistTutorial.java</a> which you created in Lesson 1.

<h3>Download the tutorial file <a href="./src/lesson1/DistTutorial.java">DistTutorial.java</a>.</h3>

<p/>After you compile the code, you can either run multiple nodes on 1 computer (but in separate processes) or if you have multiple computers, you can launch them on different machines as long as the computers can communicate with each other via IP.  In other words, it won't work if the computers are behind different firewalls.

<ul>
  <li><b>Step 1:</b> Compile
    <ol type="i">
      <li>Setup your directory as follows:
<pre>
FreePastry-1.4.1.jar
rice/tutorial/lesson1/DistTutorial.java
</pre>
      </li>
      <li>Compile the Java sources:
	  <pre><span class="input">javac -classpath FreePastry-1.4.1.jar rice/tutorial/lesson1/*.java</span></pre></li>
    </ol>
  <li><b>Step 2:</b> Launch the bootstrap node.
Even though this is the first node, and therefore we know the bootstrap will
not work, you need to place in a bogus ip/port.  A smarter <code>main()</code> method in DistTutorial.java could fix this problem.
<pre><span class="input">java -cp .:FreePastry-1.4.1.jar rice.tutorial.lesson1.DistTutorial 9001 <i>yourhost.domain</i> 9001</span></pre>
<p>
(In the above command, <i>yourhost.domain</i> can be the DNS name of your
host or its IP address.)  Your output will look something like this:</p>
<pre>
<span class="input">java -cp .:FreePastry-1.4.1.jar rice.tutorial.lesson1.DistTutorial 9001 10.9.8.7 9001</span>
<span class="output">Error connecting to address /10.9.8.7:9001: java.net.ConnectException: Connection refused: no further information
Couldn't find a bootstrap node, starting a new ring...
Finished creating new node SocketNodeHandle (&lt;0xB7E151..&gt;/FOO/10.9.8.7:9001 [-4233509936758121968])</span></pre></li>
  <li><b>Step 3:</b> Launch another node.
  <p>
  You can do this on another computer but make sure you fill in the name of
  the computer from step 2 in <i>bootstraphost.domain</i>.</p>
<pre><span class="input">java -cp .:FreePastry-1.4.1.jar rice.tutorial.lesson1.DistTutorial 9002 <i>bootstraphost.domain</i> 9001</span></pre>
<p/> Your output will look something like this:    
<pre>
<span class="input">java -cp .:FreePastry-1.4.1.jar rice.tutorial.lesson1.DistTutorial 9002 10.9.8.7 9001</span>
<span class="output">Finished creating new node SocketNodeHandle (&lt;0x74345D..&gt;/FOO/10.9.8.7:9002 [6054526012380911947])</span></pre></li>
</ul>

<h3>Congratulations!  You have just launched your first FreePastry ring!<br>
Lesson 3 will show you how to send and receive messages by creating a commonAPI application.</h3>

<hr/>

<a name="lesson3"></a><h1>Lesson 3</h1>
<h2>Write a simple application using the commonAPI.</h2>
<h3>Download the tutorial files: 
<a href="./src/lesson3/DistTutorial.java">DistTutorial.java</a> (changed from Lesson 1!!!),
<a href="./src/lesson3/MyApp.java">MyApp.java</a>,
<a href="./src/lesson3/MyMsg.java">MyMsg.java</a> into a directory called rice/tutorial/lesson3/.</h3>

<p/>This tutorial will show you how to create and run your first FreePastry application.  You will be able to send/receive messages with this application.

<h2>Terms:</h2>
<ul>
  <li><b>CommonAPI</b>&mdash;Universal interface to structured overlays.  <i>The rice.p2p.commonapi package provides an interface similar to the one provided in 'Towards a Common API for Structured Peer-to-Peer Overlays', by F. Dabek, B. Zhao, P. Druschel, J. Kubiatowicz, and I. Stoica, published in the second International Workshop on Peer-to-Peer Systems, Berkeley, CA, February 2003.  The API is designed to allow applications to be written in a protocol-independent manner, allowing the easy migration of applications from Pastry to Chord to CAN to Tapestry, etc....  Applications need only interact with the interfaces in the rice.p2p.commonapi package, and need not worry about anything in the rice.pastry packages.</i></li>
  
  <li><b>Application</b>&mdash;A program that runs on a Node.   <i>This is an interface which all applications on top of a Node must export.  This interface allows the underlying node to deliver message, inform the application of passing messages, and changes in the neighbor nodes.
      <p/>You can have multiple Applications on a single node, and you can even have multiple </i>instances<i> of an Application on the same node.  Why would you want multiple instances on the same node?  Many applications in FreePastry are intermediate applications that provide a service for higher level applications.  It is convenient to have a separate instances of say... Scribe for each higher application that would like to multicast.  This way you know that any messages that scribe delivers are in regards to your higher level traffic, and you don't need to distinguish that traffic between multiple high level applications.</i></li>
  <li><b>Endpoint.java</b>&mdash;This interface represents an endpoint which applications can use to send messages from.  <i>An endpoint is obtained by the registerApplication() method in Node.  The endpoint represents the applications' view of the world.</i></li>
  
  <li><b>Id.java</b>&mdash;This interface is the abstraction of an Id in a structured overlay.  <i>The only assumption that is made is that the Id space is circular.  An Id could represent a live node in the network, an object in the network, or simply a random Id.  NodeId implements this interface.</i></li>

  <li><b>Message.java</b>&mdash;This interface represents the abstraction of a message in the common API.  <i>Thus, messages sent to other nodes should extend or implement this class.  FreePastry sends messages around the network by first converting them to a byte stream using java serialization.</i></li>
</ul>

<h3>MyMsg</h3>
<p/>Let's start by taking a look at your message class.  In FreePastry a Message is an Object that is Serializable.  The transport layer serializes this object into bytes then sends it through the network.  When the message is received, it is deserialized back into an Object and delivered to your application.
<pre>
public class MyMsg implements Message {
</pre>
<p>This class implements <code>rice.p2p.commonapi.Message</code>.  Message
extends Serializable and has a single method: <code>getPriority()</code>.
Let's take a look at that method now.  </p>

<p>For now always return Message.LOW_PRIORITY for your messages.  It is important to not set application message priority too high, or you may interfere with Pastry's overlay maintenance traffic that keeps the ring functioning properly.
</p>
<pre>
  public int getPriority() {
    return Message.LOW_PRIORITY;
  }
</pre>

The "payload" of your message is created by making member variables in your message.  Here is the payload for <code>MyMsg</code>.  An Id is the commonAPI version of a NodeId, it is also used as the "key" when routing.

<pre>
  /**
   * Where the Message came from.
   */
  Id from;
  /**
   * Where the Message is going.
   */
  Id to;
</pre>

We will create a <code>toString()</code> so that we can print out the message.

<pre>
  public String toString() {
    return "MyMsg from "+from+" to "+to;
  }
</pre>

Finally we have the constructor that loads the payload.

<pre>
  public MyMsg(Id from, Id to) {
    this.from = from;
    this.to = to;
  }
</pre>

<h3>MyApp</h3>

<p/>Now let's take a look at MyApp.  MyApp is designed to log output whenever we send or receive a message.

<p/>The Endpoint is what we will call on to send messages.
<pre>
  protected Endpoint endpoint;
</pre>

<p/>The constructor generates an Endpoint from the node.  The instance is designed to allow you to run the same app multiple times on the same node.  The apps will not receive each other's messages.  You will only be able to send messages to apps that generated endpoints with the same instance string.  For most of your apps, you will only run one instance, so just make sure the instance is the same on all nodes.
<pre>
  public MyApp(Node node) {
    // We are only going to use one instance of this application on each PastryNode
    this.endpoint = node.registerApplication(this, "myinstance");
  }
</pre>


<h4>Sending a message:</h4>

<p/>In a Distributed Hash Table, or DHT, you typically want to route to the nearest node to the hash of an object that you are interested in.  The commonAPI provides you with <code>Endpoint.route()</code> to accomplish this.  This function sends a <code>MyMsg</code> to an id.  
<pre>
  /**
   * Called to route a message to the id
   */
  public void routeMyMsg(Id id) {
    System.out.println(this+" sending to "+id);    
    Message msg = new MyMsg(endpoint.getId(), id);
    endpoint.route(id, msg, null);
  }
</pre>

Note that <code>Endpoint.route()</code> takes 3 arguments.  They are:
<ol>
  <li><b>Id</b>&mdash;the destination of the message <em>(optional)</em></li>
  <li><b>Message</b>&mdash;the message to send</li>
  <li><b>NodeHandle</b>&mdash;a "hint": the node to route to first <em>(optional)</em></li>
</ol>

Sometimes you need to send messages to a particular Node in the network, not
just to the nearest key.  For example, if you need to send messages that are
large, they are going to take up a lot of bandwidth; it is more efficient to
<i>not</i> route the messages through the overlay, but rather send directly to
the node.  You can use the <code>Endpoint.route()</code> method to accomplish
this by passing a <code>null</code> argument as the Id and the target node's NodeHandle as the "hint" argument.
<pre>
  /**
   * Called to directly send a message to the nh
   */
  public void routeMyMsgDirect(NodeHandle nh) {
    System.out.println(this+" sending direct to "+nh);
    Message msg = new MyMsg(endpoint.getId(), nh.getId());
    endpoint.route(null, msg, nh);
  }</pre>

<h4>Receiving a message:</h4>
<p/>Simply implement the <code>deliver()</code> method as is specified by the Application interface.
<pre>
  /**
   * Called when we receive a message.
   */
  public void deliver(Id id, Message message) {
    System.out.println(this+" received "+message);
  }
</pre>

<p/>For now you don't need to worry about the additional methods in the Application interface.

  
<h3>Congratulations, you have an application.  Let's integrate it into DistTutorial.java</h3>

Here is the new code we will add to the bottom of the DistTutorial constructor:
<pre>
    // construct a new MyApp
    MyApp app = new MyApp(node);
    
    // wait 10 seconds
    Thread.sleep(10000);
    
    // as long as we're not the first node
    if (bootHandle != null) {
      
      // route 10 messages
      for (int i = 0; i &lt; 10; i++) {
        // pick a key at random
        Id randId = nidFactory.generateNodeId();
        
        // send to that key
        app.routeMyMsg(randId);
        
        // wait a sec
        Thread.sleep(1000);
      }

      // wait 10 seconds
      Thread.sleep(10000);
      
      // send directly to my leafset
      LeafSet leafSet = node.getLeafSet();
      
      // this is a typical loop to cover your leafset.  Note that if the leafset
      // overlaps, then duplicate nodes will be sent to twice
      for (int i=-leafSet.ccwSize(); i&lt;=leafSet.cwSize(); i++) {
        if (i != 0) { // don't send to self
          // select the item
          NodeHandle nh = leafSet.get(i);
          
          // send the message directly to the node
          app.routeMyMsgDirect(nh);   
          
          // wait a sec
          Thread.sleep(1000);
        }
      }
    }
</pre>

 <p>First we create the MyApp.</p>
  <pre>
    // construct a new MyApp
    MyApp app = new MyApp(node);  
  </pre>

 <p>After waiting 10 seconds, let's send some messages, but only if I am not
 the first node.  After all, if I'm the only node in the ring, it is hardly
 interesting to send messages to myself.</p>
  <pre>
    if (bootHandle != null) {</pre>
Loop 10 times.  
  <pre>
      for (int i = 0; i &lt; 10; i++) {</pre>
  
Reuse the RandomNodeIdFactory to generate random keys to route to.  
  <pre>
        Id randId = nidFactory.generateNodeId();</pre>
  
Route.
  <pre>
        app.routeMyMsg(randId);</pre>
  
Wait a second and repeat.
  <pre>
        Thread.sleep(1000);
      }</pre>  
 <p>After waiting another 10 seconds, let's send some messages directly to
 nodes.  This section is also going to show you how to access the leafset from
 the PastryNode.  Note that this is a FreePastry specific call, not a
 commonAPI call.</p>
 <p>Get the leafset from the PastryNode:</p>
  <pre>
      LeafSet leafSet = node.getLeafSet();</pre>
Iterate over all of the nodes in the leafset.  
  <pre>
      for (int i=-leafSet.ccwSize(); i&lt;=leafSet.cwSize(); i++) {</pre>
  
  
Don't send to myself.  The local node is node zero in the leafset.
  <pre>
        if (i != 0) { // don't send to self</pre>
  
Extract the nodehandle at that index.
  <pre>
          NodeHandle nh = leafSet.get(i);</pre>
  
Wait a second and repeat.
  <pre>
        Thread.sleep(1000);
      }</pre>  
  
Send the message.
  <pre>
          app.routeMyMsgDirect(nh);   
      }</pre>  

  
Now if you execute this code twice you should get something like:

<p><em>(for Node1)</em></p>
<pre>
<span class="input">java -cp .:FreePastry-1.4.1.jar rice.tutorial.lesson3.DistTutorial 9001 10.9.8.7 9001</span>
<span class="output">Error connecting to address /10.9.8.7:9001: java.net.ConnectException: Connection refused: no further information
Couldn't find a bootstrap node, starting a new ring...
Finished creating new node SocketNodeHandle (&lt;0xC20545..&gt;/FOO/10.9.8.7:9001 [-4445364026872145996])

MyApp &lt;0xC20545..&gt; received MyMsg from &lt;0xDD90C6..&gt; to &lt;0xA67C20..&gt;
MyApp &lt;0xC20545..&gt; received MyMsg from &lt;0xDD90C6..&gt; to &lt;0xBF799E..&gt;
MyApp &lt;0xC20545..&gt; received MyMsg from &lt;0xDD90C6..&gt; to &lt;0xC4BEE7..&gt;
MyApp &lt;0xC20545..&gt; received MyMsg from &lt;0xDD90C6..&gt; to &lt;0x86ACA9..&gt;
MyApp &lt;0xC20545..&gt; received MyMsg from &lt;0xDD90C6..&gt; to &lt;0x9906E6..&gt;
MyApp &lt;0xC20545..&gt; received MyMsg from &lt;0xDD90C6..&gt; to &lt;0x8F5015..&gt;
MyApp &lt;0xC20545..&gt; received MyMsg from &lt;0xDD90C6..&gt; to &lt;0xC20545..&gt;
MyApp &lt;0xC20545..&gt; received MyMsg from &lt;0xDD90C6..&gt; to &lt;0xC20545..&gt;</span></pre>

<p><em>(for Node2)</em></p>
<pre>
<span class="input">java -cp .:FreePastry-1.4.1.jar rice.tutorial.lesson3.DistTutorial 9002 10.9.8.7 9001</span>
<span class="output">Finished creating new node SocketNodeHandle (&lt;0xDD90C6..&gt;/FOO/10.9.8.7:9002 [5138450490561334965])

MyApp &lt;0xDD90C6..&gt; sending to &lt;0x2E5C63..&gt;
MyApp &lt;0xDD90C6..&gt; received MyMsg from &lt;0xDD90C6..&gt; to &lt;0x2E5C63..&gt;
MyApp &lt;0xDD90C6..&gt; sending to &lt;0x03045C..&gt;
MyApp &lt;0xDD90C6..&gt; received MyMsg from &lt;0xDD90C6..&gt; to &lt;0x03045C..&gt;
MyApp &lt;0xDD90C6..&gt; sending to &lt;0xA67C20..&gt;
MyApp &lt;0xDD90C6..&gt; sending to &lt;0xF9C506..&gt;
MyApp &lt;0xDD90C6..&gt; received MyMsg from &lt;0xDD90C6..&gt; to &lt;0xF9C506..&gt;
MyApp &lt;0xDD90C6..&gt; sending to &lt;0xBF799E..&gt;
MyApp &lt;0xDD90C6..&gt; sending to &lt;0xC4BEE7..&gt;
MyApp &lt;0xDD90C6..&gt; sending to &lt;0x86ACA9..&gt;
MyApp &lt;0xDD90C6..&gt; sending to &lt;0x41F900..&gt;
MyApp &lt;0xDD90C6..&gt; received MyMsg from &lt;0xDD90C6..&gt; to &lt;0x41F900..&gt;
MyApp &lt;0xDD90C6..&gt; sending to &lt;0x9906E6..&gt;
MyApp &lt;0xDD90C6..&gt; sending to &lt;0x8F5015..&gt;
MyApp &lt;0xDD90C6..&gt; sending direct to [SNH: &lt;0xDD90C6..&gt; -&gt; &lt;0xC20545..&gt;/FOO/10.9.8.7:9001 [-4445364026872145996]]
MyApp &lt;0xDD90C6..&gt; sending direct to [SNH: &lt;0xDD90C6..&gt; -&gt; &lt;0xC20545..&gt;/FOO/10.9.8.7:9001 [-4445364026872145996]]</span></pre>

<h3>Congratulations!  You have just sent and received your first messages in
FreePastry!</h3>

<a name="lesson4"></a><h1>Lesson 4</h1>
<h2>Running multiple nodes in the same JVM.</h2>
<h3>Download the tutorial files: 
<a href="./src/lesson4/DistTutorial.java">DistTutorial.java</a> (changed from Lesson 3!!!),
<a href="./src/lesson4/MyApp.java">MyApp.java</a>,
<a href="./src/lesson4/MyMsg.java">MyMsg.java</a> into a directory called rice/tutorial/lesson4/.</h3>

<p/>This tutorial will show you how to create and run multiple FreePastry nodes within the same JVM.  We will continue to use the Socket transport layer.  This tutorial is very simple, all we will be doing is modifying lesson 3 to have multiple nodes.<br>  

Let's start with the changes to MyApp.  We are going to make it keep a reference to the Node with a member variable named <code>node</code>.  It will become apparent later in this tutorial. 
<pre>
  protected Node node;
</pre>  

In the constructor:
<pre>
    this.node = node;
</pre>  

And here is the getter:
<pre>
  public Node getNode() {
    return node;
  }
</pre>  

Now we will look at the changes to DistTutorial.  We have a member variable <code>apps</code> that will keep track of the list of apps.
<pre>
  Vector apps = new Vector();
</pre>  

We modify the constructor to take in how many nodes we wish to create:
<pre>
  public DistTutorial(int bindport, InetSocketAddress bootaddress, int numNodes) throws Exception {
</pre>

After constructing the <code>PastryNodeFactory</code> we create a loop to construct the nodes, and add them to our <code>apps</code> Vector.
<pre>
    for (int curNode = 0; curNode < numNodes; curNode++) {
	    
	    ...
	    
	    apps.add(app); 
    }
</pre>

When routing messages, we have created a subloop to do so for each app in the system:
<pre>
      // for each app
      Iterator appIterator = apps.iterator();
      while(appIterator.hasNext()) {
        MyApp app = (MyApp)appIterator.next();
        
        ...
        
      }
</pre>

Note that we eliminated this code, because it is no longer important to not route if we are the bootstrap.
<pre>
    // as long as we're not the first node
    if (bootHandle != null) {
</pre>


In the send direct loop we use our getter <code>MyApp.getNode()</code>.  This prevents us from having to remember a parallel data structure for the Nodes.  
<pre>
    // for each app
    Iterator appIterator = apps.iterator();
    while(appIterator.hasNext()) {
      MyApp app = (MyApp)appIterator.next();
      PastryNode node = (PastryNode)app.getNode();
</pre>

Other than that, we changed the delay in several locations so the program doesn't take as long to execute.  Compile and run this program as before, but make sure to specify some the number of nodes to run as the 4th argument.
<pre>
<span class="input">java -cp .:FreePastry-1.4.1.jar rice.tutorial.lesson4.DistTutorial 9001 10.9.8.7 9001 10</span>
<span class="output">Error connecting to address /10.9.8.7:9001: java.net.ConnectException: Connection refused: no further information
Couldn't find a bootstrap node, starting a new ring...
Finished creating new node SocketNodeHandle (&lt;0x93426F..&gt;/FOO/10.9.8.7:9001 [6666451457797044406])

Finished creating new node SocketNodeHandle (&lt;0xAE1B63..&gt;/FOO/10.9.8.7:9002 [8904287830673843378])

Finished creating new node SocketNodeHandle (&lt;0x3E99E3..&gt;/FOO/10.9.8.7:9003 [-1171813548315184530])

Finished creating new node SocketNodeHandle (&lt;0xC8715F..&gt;/FOO/10.9.8.7:9004 [6496343980737954414])

Finished creating new node SocketNodeHandle (&lt;0x688826..&gt;/FOO/10.9.8.7:9005 [-6779179910423314388])

Finished creating new node SocketNodeHandle (&lt;0x640179..&gt;/FOO/10.9.8.7:9006 [3471226224877450778])

Finished creating new node SocketNodeHandle (&lt;0x7A6F99..&gt;/FOO/10.9.8.7:9007 [7101267768505206817])

Finished creating new node SocketNodeHandle (&lt;0xD5DAAE..&gt;/FOO/10.9.8.7:9008 [7899110252170216207])

Finished creating new node SocketNodeHandle (&lt;0x19C832..&gt;/FOO/10.9.8.7:9009 [-4206970387543598705])

Finished creating new node SocketNodeHandle (&lt;0x490C38..&gt;/FOO/10.9.8.7:9010 [-6742572645641651296])

MyApp &lt;0x93426F..&gt; sending to &lt;0x0E510A..&gt;
MyApp &lt;0x19C832..&gt; received MyMsg from &lt;0x93426F..&gt; to &lt;0x0E510A..&gt;
MyApp &lt;0xAE1B63..&gt; sending to &lt;0xE704A5..&gt;
MyApp &lt;0xD5DAAE..&gt; received MyMsg from &lt;0xAE1B63..&gt; to &lt;0xE704A5..&gt;
MyApp &lt;0x3E99E3..&gt; sending to &lt;0x533803..&gt;
MyApp &lt;0x490C38..&gt; received MyMsg from &lt;0x3E99E3..&gt; to &lt;0x533803..&gt;
MyApp &lt;0xC8715F..&gt; sending to &lt;0x779E75..&gt;
MyApp &lt;0x7A6F99..&gt; received MyMsg from &lt;0xC8715F..&gt; to &lt;0x779E75..&gt;
MyApp &lt;0x688826..&gt; sending to &lt;0x3FFFB9..&gt;
MyApp &lt;0x3E99E3..&gt; received MyMsg from &lt;0x688826..&gt; to &lt;0x3FFFB9..&gt;

...

MyApp &lt;0x93426F..&gt; sending direct to [SNH: &lt;0x93426F..&gt; -&gt; &lt;0xAE1B63..&gt;/FOO/10.9.8.7:9002 [8904287830673843378]]
MyApp &lt;0xAE1B63..&gt; received MyMsg from &lt;0x93426F..&gt; to &lt;0xAE1B63..&gt;
MyApp &lt;0x93426F..&gt; sending direct to [SNH: &lt;0x93426F..&gt; -&gt; &lt;0xC8715F..&gt;/FOO/10.9.8.7:9004 [6496343980737954414]]
MyApp &lt;0xC8715F..&gt; received MyMsg from &lt;0x93426F..&gt; to &lt;0xC8715F..&gt;
MyApp &lt;0x93426F..&gt; sending direct to [SNH: &lt;0x93426F..&gt; -&gt; &lt;0xD5DAAE..&gt;/FOO/10.9.8.7:9008 [7899110252170216207]]
MyApp &lt;0xD5DAAE..&gt; received MyMsg from &lt;0x93426F..&gt; to &lt;0xD5DAAE..&gt;
MyApp &lt;0x93426F..&gt; sending direct to [SNH: &lt;0x93426F..&gt; -&gt; &lt;0x19C832..&gt;/FOO/10.9.8.7:9009 [-4206970387543598705]]
MyApp &lt;0x19C832..&gt; received MyMsg from &lt;0x93426F..&gt; to &lt;0x19C832..&gt;
MyApp &lt;0x93426F..&gt; sending direct to [SNH: &lt;0x93426F..&gt; -&gt; &lt;0x3E99E3..&gt;/FOO/10.9.8.7:9003 [-1171813548315184530]]
MyApp &lt;0x3E99E3..&gt; received MyMsg from &lt;0x93426F..&gt; to &lt;0x3E99E3..&gt;
MyApp &lt;0x93426F..&gt; sending direct to [SNH: &lt;0x93426F..&gt; -&gt; &lt;0x490C38..&gt;/FOO/10.9.8.7:9010 [-6742572645641651296]]
MyApp &lt;0x490C38..&gt; received MyMsg from &lt;0x93426F..&gt; to &lt;0x490C38..&gt;

...

</span></pre>
<h3>Congratulations!  You have just created an entire ring inside a single JVM.  This should make it much easier to test your application.</h3>

<a name="lesson5"></a><h1>Lesson 5</h1>
<h2>Scheduling tasks on the FreePastry timer.</h2>
<h3>Download the tutorial files: 
<a href="./src/lesson5/DistTutorial.java">DistTutorial.java</a>,
<a href="./src/lesson5/MyApp.java">MyApp.java</a> into a directory called rice/tutorial/lesson5/.</h3>

<p/>This tutorial will show you how to schedule a task on the FreePastry thread.  To be compatible
with the commonAPI, the approach is to schedule a message to be sent to yourself at a regular interval.<br/>  

<p/>Let's start with the changes to MyApp.  

<p/>First a simple message.
<pre>
  class MessageToSelf implements Message {
    public int getPriority() {
      return 0;
    }    
  }
</pre>

<p/>Note that due to laziness, I have constructed this Message as an inner class
of MyApp.  This is fine for what we are going to use it for, but beware that 
it you will get a NotSerializableException if you attempt to send this 
message over the wire.  While the Message may be serializable it has an implicit
reference to MyApp, the containing class.  When the message is serialized,
FreePastry will also attempt to serialize MyApp which will fail and throw the 
exception.

<p/>Here is the change to the constructor of MyApp, where we schedule the 
MessageToSelf.  The first parameter is the <code>Message</code> that will be sent to
MyApp.  The second is the delay (in millis) until it is first sent.  The third parameter 
is the period at which the message should be repeated.  

<pre>
    // Send MessageToSelf every 5 seconds, starting in 3 seconds
    messageToSelfTask = endpoint.scheduleMessage(new MessageToSelf(), 3000, 5000);
</pre>  

<p/>As you can see, we have asked FreePastry to deliver the MessageToSelf in 3 seconds, and
then continue to deliver it again every 5 seconds.  Note that there is also a version
of scheduleMessage() that doesn't take the 3rd parameter, and therefore doesn't repeat.

<p/>We stored the task as a member variable so that we can 
cancel it later.
<pre>
  CancellableTask messageToSelfTask;
</pre>  


<p/>Whenever we receive the MessageToSelf we are just going to print out the current time.
However, in your application you could call a method to do routine maintenance, send 
messages to other nodes etc.
<pre>
  public void deliver(Id id, Message message) {
    System.out.println(this+" received "+message);
    if (message instanceof MessageToSelf) {
      // This will get called every 5 seconds, on Pastry's thread.
      // Thus now we can assume we are on Pastry's thread.
      // TODO: whatever... send messages to other nodes? print out status?
      System.out.println("I got the MessageToSelf at time:"+System.currentTimeMillis());
    }
  }
</pre>

<p/>Finally, we make a public method to cancel the task.
<pre>
  public void cancelTask() {
    messageToSelfTask.cancel(); 
  }
</pre>

<p/>The DistTutorial.java is based on lesson3, but we removed the code to print the leafset.  For this 
example it is unnecessary to launch multiple pastry nodes, so we will only launch one.  We added a bit of 
code after constructing the MyApp to cancel the task after 15 seconds.

<pre>
    // construct a new MyApp
    MyApp app = new MyApp(node);
    
    // wait 15 seconds
    Thread.sleep(15000);
    
    // cancel the task
    app.cancelTask();
</pre>

<p/>Ok, time to run it!  Your output should resemble the following:
<pre>
<span class="input">java -cp .:FreePastry-1.4.1.jar rice.tutorial.lesson5.DistTutorial 9001 localhost 9001</span>
<span class="output">Error connecting to address localhost/127.0.0.1:9001: java.net.ConnectException: Connection refused: no further information
Couldn't find a bootstrap node, starting a new ring...
Finished creating new node SocketNodeHandle (&lt;0x3C1EEA..&gt;/FOO/10.9.8.7:9001 [9038308767327354496])

MyApp &lt;0x3C1EEA..&gt; received rice.tutorial.lesson5.MyApp$MessageToSelf@d70d7a
I got the MessageToSelf at time:1115228553359
MyApp &lt;0x3C1EEA..&gt; received rice.tutorial.lesson5.MyApp$MessageToSelf@d70d7a
I got the MessageToSelf at time:1115228558359
MyApp &lt;0x3C1EEA..&gt; received rice.tutorial.lesson5.MyApp$MessageToSelf@d70d7a
I got the MessageToSelf at time:1115228563359
</span></pre>
<h3>Congratulations!  Now you can schedule and cancel tasks without launching your own thread.</h3>

<a name="lesson6"></a><h1>Lesson 6</h1>
<h2>Introducing Scribe.</h2>
<h3>Download the tutorial files: 
<a href="./src/lesson6/MyScribeClient.java">MyScribeClient.java</a>,
<a href="./src/lesson6/MyScribeContent.java">MyScribeContent.java</a>,
<a href="./src/lesson6/ScribeTutorial.java">ScribeTutorial.java</a> into a directory called rice/tutorial/lesson6/.</h3>

<p/>This tutorial will show you how to get scribe up and running.  You will learn how to do the following:
<ul>
 <li><a href="#l6Topic">Create a topic.</a></li>
 <li><a href="#l6Client">Create a ScribeClient.</a></li>
 <li><a href="#l6Subscribe">Subscribe to a topic.</a></li>
 <li><a href="#l6Publish">Publish (Multicast) content.</a></li>
 <li><a href="#l6Receive">Receive content.</a></li>
 <li><a href="#l6Anycast">Anycast content.</a></li>
 <li><a href="#l6Tree">Introspect into the tree.</a></li>
</ul>


The next tutorial, Lesson 7: Advanced Scribe: Policies, will show you how to control tree formation and anycast selection.

<h2>Terms:</h2>
<ul>
  <li><b>Scribe</b>&mdash;A scalable group communication system for topic-based publish-subscribe applications.<i>Scribe builds an efficient multicast tree for dissemination of events to a topic.</i></li>
  <li><b>Topic</b>&mdash;Group.  <i>A topic builds a hash of the group name which is used as a unique identifier for the topic, as well used as a rendezvous point in Pastry.</i></li>
  <li><b>IdFactory</b>&mdash;A hash function.  <i>An IdFactory implements a hash function to build Ids that are compatable with pastry.</i></li>
  <li><b>PastryIdFactory</b>&mdash;A commonly used IdFactory in Pastry.  <i>The PastryIdFactory uses SHA1 as it's underlieing hash function.</i></li>
  <li><b>ScribeContent</b>&mdash;A scribe message.</li>
  <li><b>ScribeClient</b>&mdash;An application that receives ScribeContent.  <i>The client can subscribe to one or more topics.</i></li>
  <li><b>Multicast</b>&mdash;A broadcast received by everyone subscribed to the corresponding topic.</i></li>  
  <li><b>Anycast</b>&mdash;A message that is received by a single node in a group.  <i>Anycast is most commonly used to find a single available service provider.  The anycast message will be rejected until it finds a node willing to supply the service that is being requested.</i></li>  
  <li><b>ScribePolicy</b>&mdash;A policy to determine application specific details of Scribe.  <i>This includes formation and anycast selection.</i></li>  
</ul>


<a name="l6Topic"></a><h3>Creating a topic.</h3>
This is fairly straightforward, but each node will have to do this for each topic of interest.
<pre>
  Topic myTopic = new Topic(new PastryIdFactory(), "example topic");
</pre>
This constructs a topic with the "common name" of "example topic".  It uses the PastryIdFactory to generate an 
appropriate Id for this topic. 

<a name="l6Client"></a><h3>Creating a ScribeClient.</h3>
Let's take a look at MyScribeClient.  We are only going to subscribe to a single topic.  We are going to publish content every 5 seconds using the FreePastry timer.  See <a href="#lesson5">Lesson 5</a> for more details on the timer.  The client is also going to implement rice.p2p.commonapi.Application in addition to rice.p2p.scribe.ScribeClient.  This will allow us to send and receive non-scribe messages should this be important.  Specifically it will allow us to receive messages queued on the timer.<br/><br/>
Here's the constructor and some member variables:
<pre>
  Scribe myScribe;
  Topic myTopic;
  protected Endpoint endpoint;
  public MyScribeClient(PastryNode node) {
    // you should recognize this from lesson 3
    this.endpoint = node.registerApplication(this, "myinstance");
    // construct Scribe
    myScribe = new ScribeImpl(node,"lesson6instance");
    // construct the topic
    myTopic = new Topic(new PastryIdFactory(), "example topic");
    System.out.println("myTopic = "+myTopic);
  }
</pre>
The only thing that should be new here is the construction of the ScribeImpl.  The instance name "lesson6instance" allows you to remain independent of other applications running on the 
same ring who also use scribe.  They will have their own instance of Scribe that won't be confused with your instance.<br/>

In this example, one of the nodes is going to publish content every 5 seconds.  We use the timer pattern described in Lesson 5.  Each time we are going to send 1 
multicast, and 1 anycast.
<pre>
  class PublishContent implements Message {
    public int getPriority() {
      return 0;
    }
  }
  public void startPublishTask() {
    publishTask = endpoint.scheduleMessage(new PublishContent(), 5000, 5000);    
  }
  public void deliver(Id id, Message message) {
    if (message instanceof PublishContent) {
      sendMulticast(); 
      sendAnycast();
    }
  }
</pre>
In case you forgot, the <code>PublishContent</code> is similar to Lesson 5's <code>MessageToSelf</code>.  
The <code>startPublishTask()</code> method schedules this to be delivered locally every 5 seconds.
The <code>deliver(id,message)</code> method calls <code>sendMulticast()</code> when the <code>PublishMethod</code> is received.  
In your application you will likely have some other event that causes content to be published.
We will look at <code>sendMulticast()</code> and <code>sendAnycast()</code> shortly.

<a name="l6Subscribe"></a><h3>Subscribing to a group.</h3>
Subscribing is very easy.  Just call <code>Scribe.subscribe()</code> and provide the topic, and your client.
<pre>
  public void subscribe() {
    myScribe.subscribe(myTopic, this); 
  }
</pre>

<a name="l6Publish"></a><h3>Multicasting content.</h3>
First, we need some content to send.  MyScribeContent implements ScribeContent and takes 
a NodeHandle sender, and an int sequence number.  These are just so the output of the 
program is more interesting.
<pre>
public class MyScribeContent implements ScribeContent {
  NodeHandle from;
  int seq;
 
  public MyScribeContent(NodeHandle from, int seq) {
    this.from = from;
    this.seq = seq;
  }

  public String toString() {
    return "MyScribeContent #"+seq+" from "+from;
  }  
}
</pre>

To send the content, simply construct the message, then call Scribe.publish().  You give it
the topic and the message.  The rest of this function is just to print output and update the 
sequence number.
<pre>
  public void sendMulticast() {
    System.out.println("Node "+endpoint.getLocalNodeHandle()+" broadcasting "+seqNum);
    MyScribeContent myMessage = new MyScribeContent(endpoint.getLocalNodeHandle(), seqNum);
    myScribe.publish(myTopic, myMessage); 
    seqNum++;
  }
</pre>

<a name="l6Receive"></a><h3>Receiving content.</h3>
Receiving content is as easy as any other p2p application.  The method signature is only
slightly different:

<pre>
  public void deliver(Topic topic, ScribeContent content) {
    System.out.println("MyScribeClient.deliver("+topic+","+content+")");
  }
</pre>

All we are doing here is printing output to stdout.

<a name="l6Anycast"></a><h3>Anycasting.</h3>
Anycast will get called on your clients until one returns true.  This occurs on
a call to <code>ScribeClient.anycast()</code>.  To make this interesting, we're going to only accept the message 
1/3 of the time, randomly.  Your application will ususally want to do something more interesting, such as see 
if a requested resource is available.<br/>
Here is <code>sendAnycast()</code> which is nearly identical to <code>sendMulticast()</code> except for the call to 
<code>Scribe.anycast()</code> instead of <code>Scribe.publish()</code>.

<pre>
  public void sendAnycast() {
    System.out.println("Node "+endpoint.getLocalNodeHandle()+" anycasting "+seqNum);
    MyScribeContent myMessage = new MyScribeContent(endpoint.getLocalNodeHandle(), seqNum);
    myScribe.anycast(myTopic, myMessage); 
    seqNum++;
  }
</pre>

Here is the code that only accepts the anycast 1/3 of the time.  This will allow us to see
that the anycast message can be rejected and sent elsewhere.
<pre>
  public boolean anycast(Topic topic, ScribeContent content) {
    boolean returnValue = rng.nextInt(3) == 0;
    System.out.println("MyScribeClient.anycast("+topic+","+content+"):"+returnValue);
    return returnValue;
  }
</pre>


<a name="l6Tree"></a><h3>Examining the tree.</h3>
Lastly we have code to introspect the tree.  Note that it is only easy to print out the
entire tree because we are running all of the nodes in the same VM and have global 
information.  It is significantly more difficult to print the scribe tree in an actual
distributed environment, as scribe does not provide this information automatically.  Furthermore
this information could change rapidly as nodes join and leave.<br/><br/>

Because we are only going to run the application with a small number of nodes, the tree
will most likely be only 1 level deep.  (The root being level 0).  However, this will show you how to print out your parent 
and children.<br/><br/>  

The first thing to note is that we have 3 accessor methods at the bottom of <code>MyScribeContent</code>:

<pre>
  public boolean isRoot() {
    return myScribe.isRoot(myTopic);
  }
  
  public NodeHandle getParent() {
    return myScribe.getParent(myTopic); 
  }
  
  public NodeHandle[] getChildren() {
    return myScribe.getChildren(myTopic); 
  }
</pre>

Note that these simply call through to the same method on myScribe, with the correct topic.<br/><br/>


This code can be found in <code>ScribeTutorial.java</code><br/><br/>

<code>printTree()</code> does the following:
<ol>
  <li>Create a table mapping <code>NodeHandle</code> to <code>MyScribeClient</code>.</li>
  <li>Recursively traverse the tree to the root, using the helper: <code>getRoot()</code>.</li>
  <li>Recursively traverse the tree down from the root, depth first and print the nodes using the helper: <code>recursivelyPrintChildren()</code>.</li>
</ol>

<pre>
  public static void printTree(Vector apps) {
    // build a hashtable of the apps, keyed by nodehandle
    Hashtable appTable = new Hashtable();
    Iterator i = apps.iterator();
    while (i.hasNext()) {
      MyScribeClient app = (MyScribeClient)i.next();
      appTable.put(app.endpoint.getLocalNodeHandle(), app);
    }
    NodeHandle seed = ((MyScribeClient)apps.get(0)).endpoint.getLocalNodeHandle();
    
    // get the root 
    NodeHandle root = getRoot(seed, appTable);
    
    // print the tree from the root down
    recursivelyPrintChildren(root, 0, appTable);
  }
</pre>

<ol>
 <li><code>getRoot()</code> looks up the client for the seed handle from the appTable.</li>
 <li>If the seed is the root, it is returned.</li>  
 <li>Otherwise, it calls <code>getRoot()</code> on the parent.</li>
</ol>
<pre>
  public static NodeHandle getRoot(NodeHandle seed, Hashtable appTable) {
    MyScribeClient app = (MyScribeClient)appTable.get(seed);
    if (app.isRoot()) return seed;
    NodeHandle nextSeed = app.getParent();
    return getRoot(nextSeed, appTable);
  }
</pre>

<ol>
 <li><code>recursivelyPrintChildren()</code> prints the curNode with appropriate whitespace based on the depth in the tree.</li>
 <li>Then calls recursivelyPrintChildren() on all children (if it has any)</li>  
</ol>
<pre>
  public static void recursivelyPrintChildren(NodeHandle curNode, int recursionDepth, Hashtable appTable) {
    // print self at appropriate tab level
    String s = "";
    for (int numTabs = 0; numTabs < recursionDepth; numTabs++) {
      s+="  "; 
    }
    s+=curNode.getId().toString();
    System.out.println(s);
    
    // recursively print all children
    MyScribeClient app = (MyScribeClient)appTable.get(curNode);
    NodeHandle[] children = app.getChildren();
    for (int curChild = 0; curChild < children.length; curChild++) {
      recursivelyPrintChildren(children[curChild], recursionDepth+1, appTable);
    }    
  }
</pre>


<h3>Initializing the apps.</h3>
The majority of the ScribeTutorial is identical to Lesson 4 where we ran multiple nodes within the same JVM.  The last part
is listed below.  On each app, we call <code>subscribe()</code>, and on the first one we call <code>startPublishTask()</code>.  
After that we wait a few seconds then print the tree.
<pre>
    Iterator i = apps.iterator();    
    MyScribeClient app = (MyScribeClient)i.next();
    app.subscribe();
    app.startPublishTask();
    while(i.hasNext()) {
      app = (MyScribeClient)i.next();
      app.subscribe();
    }
    
    Thread.sleep(3000);
    printTree(apps);
</pre>

<h3>Execution.</h3>
The parameters are identical to those in Lesson 4: 
<ol>
  <li>Local bind port.</li>
  <li>Bootstrap host. (the local host address)</li>
  <li>Bootstrap port. (usually whatever you passed in the first arg)</li>
  <li>The number of nodes to launch.</li>
</ol>

Your output will resemble:

<pre>
<span class="input">java -cp .:FreePastry-1.4.1.jar rice.tutorial.lesson6.ScribeTutorial 9001 10.9.8.7 9001 10</span>
<span class="output">Error connecting to address /10.9.8.7:9001: java.net.ConnectException: Connection refused: no further information
Couldn't find a bootstrap node, starting a new ring...
Finished creating new node SocketNodeHandle (&lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189])

myTopic = [TOPIC &lt;0x19A8F5..&gt;]
Finished creating new node SocketNodeHandle (&lt;0x8904D9..&gt;/FOO/10.9.8.7:9002 [4410881318286179245])

myTopic = [TOPIC &lt;0x19A8F5..&gt;]
Finished creating new node SocketNodeHandle (&lt;0x281817..&gt;/FOO/10.9.8.7:9003 [1144941711194723161])

...

&lt;0x281817..&gt;
  &lt;0x8904D9..&gt;
  &lt;0x061BB8..&gt;
  &lt;0x85DA64..&gt;
  &lt;0x489BCB..&gt;
  &lt;0x0A9FCC..&gt;
  &lt;0x39CE29..&gt;
  &lt;0xA20DF8..&gt;
  &lt;0x7D350E..&gt;
  &lt;0xCF76F1..&gt;
Node [SNH: &lt;0x489BCB..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]] broadcasting 0
Node [SNH: &lt;0x489BCB..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]] anycasting 1
MyScribeClient.anycast([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #1 from [SNH: &lt;0x489BCB..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]]):false
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #0 from [SNH: &lt;0x281817..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.anycast([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #1 from [SNH: &lt;0x281817..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]]):true
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #0 from [SNH: &lt;0x8904D9..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #0 from [SNH: &lt;0xA20DF8..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #0 from [SNH: &lt;0xCF76F1..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #0 from [SNH: &lt;0x39CE29..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #0 from [SNH: &lt;0x0A9FCC..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #0 from [SNH: &lt;0x7D350E..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #0 from [SNH: &lt;0x85DA64..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #0 from [SNH: &lt;0x489BCB..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #0 from [SNH: &lt;0x061BB8..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
Node [SNH: &lt;0x489BCB..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]] broadcasting 2
Node [SNH: &lt;0x489BCB..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]] anycasting 3
MyScribeClient.anycast([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #3 from [SNH: &lt;0x489BCB..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]]):false
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #2 from [SNH: &lt;0x281817..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.anycast([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #3 from [SNH: &lt;0x281817..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]]):true
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #2 from [SNH: &lt;0x8904D9..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #2 from [SNH: &lt;0xA20DF8..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #2 from [SNH: &lt;0xCF76F1..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #2 from [SNH: &lt;0x39CE29..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #2 from [SNH: &lt;0x0A9FCC..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #2 from [SNH: &lt;0x7D350E..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #2 from [SNH: &lt;0x85DA64..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #2 from [SNH: &lt;0x489BCB..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #2 from [SNH: &lt;0x061BB8..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
Node [SNH: &lt;0x489BCB..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]] broadcasting 4
Node [SNH: &lt;0x489BCB..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]] anycasting 5
MyScribeClient.anycast([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #5 from [SNH: &lt;0x489BCB..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]]):false
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #4 from [SNH: &lt;0x281817..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.anycast([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #5 from [SNH: &lt;0x281817..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]]):false
MyScribeClient.anycast([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #5 from [SNH: &lt;0x281817..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]]):false
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #4 from [SNH: &lt;0x8904D9..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #4 from [SNH: &lt;0xA20DF8..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #4 from [SNH: &lt;0xCF76F1..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #4 from [SNH: &lt;0x39CE29..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #4 from [SNH: &lt;0x0A9FCC..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #4 from [SNH: &lt;0x7D350E..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #4 from [SNH: &lt;0x85DA64..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #4 from [SNH: &lt;0x489BCB..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.deliver([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #4 from [SNH: &lt;0x061BB8..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]])
MyScribeClient.anycast([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #5 from [SNH: &lt;0x39CE29..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]]):false
MyScribeClient.anycast([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #5 from [SNH: &lt;0x39CE29..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]]):false
MyScribeClient.anycast([TOPIC &lt;0x19A8F5..&gt;],MyScribeContent #5 from [SNH: &lt;0x8904D9..&gt; -&gt; &lt;0x489BCB..&gt;/FOO/10.9.8.7:9001 [3776408266594462189]]):true
</span></pre>

Note that the tree is only 1 level deep.<br/>
Note how each publish message is delivered to each node in the group.<br/>
Note that anycast is called on different nodes until a node returns true.<br/>  

<h3>Congratulations!  You have built and run your first scribe application!<br>

<div class="footer">
Pastry tutorial version 1.2. &nbsp;&nbsp;&nbsp; Last updated May 26, 2005.
&nbsp;&nbsp;&nbsp; For FreePastry-1.4+. &nbsp;&nbsp;&nbsp; Maintained by <a
href="mailto:jeffh@rice.edu">Jeff Hoye</a></font>
</div>

</div>
</body>
</html>
