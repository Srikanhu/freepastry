FreePastry 2.0 Serialized Message description version 0:

All numbers are in Network (Big) Endian
byte = 8 bits
boolean 1 byte
sort = 2 bytes
int = 4 bytes
long = 8 bytes
float = 4 bytes
double = 8 bytes

/********** FreePastry Core ************/
Hard Coded values: 

NodeId bit length 160
Routing Table Base Bit Length 4 


background:
  FreePastry provides a structured peer to peer routing overlay, but is not necessarally useful in of itself.  Application layers must be written on top of FreePastry.  We will call the layer above FreePastry an Application.  This application may implement a DHT (such as Past) or a Multicast Network (such as Scribe) which higher level applications may further be written on.
  FreePastry uses Source Routing to handle temporary network anomlies.  
  FreePastry uses TCP for all overlay maintenance and application traffic.
  FreePastry uses UDP for liveness checks.
  FreePastry provides a mechanism for Applications to open thier own sockets through the source routes.  This allows applications to manage their own congestion control without interfering with overlay maintenance.  However normal messages may be sent on the same sockets as overlay maintenance traffic.  Application 0 is a FreePastry control socket, and is not delivered to an application.
  From an application's perspective, the abstraction for an node in FreePastry is the NodeHandle.  
  FreePastry interacts with other nodes in the network using EpochInetSocketAddresses.  The EpochInetSocketAddress is based on IPv4 and encodes an IP address, a port, and an 8byte epoch.  The purpose of the epoch is to know if the node has rebooted since last communication.  This gives information to the applications (that may be stateful) about the state of the node.

  Here is the format for an EpochInetSocketAddress:
  
  EpochInetSocketAddress: (IPV4 FreePastry Version 0):
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  + Inet Address                                                  +
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  + port (int)                                                    +
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  + epoch (long)                                                  +
  +                                                               +
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      
TCP stream header:

Overview:
  1) Magic Number
  2) Version Number
  3) Source Route Header
  4) Application ID
  5) Application Stream


	// Magic Number
	byte[4] PASTRY_MAGIC_NUMBER = {0x27, 0x40, 0x75, 0x3A}
		
	// Protocol Version (0) for now, but this may become more interesting in the future, such as being in part, a bitwise selection
	int 0

  // Source Route Header
  // 0 or more of the following based on the number of hops in the sourceroute:
  byte[4] HEADER_SOURCE_ROUTE = {0x19, 0x53, 0x13, 0x00}
  EpochInetSocketAddress next hop
  
  // indicates that this is the end of the source route header
  byte[4] HEADER_DIRECT = {0x06, 0x1B, 0x49, 0x74}
  
  int appID // 0 is normal pastry socket, needed for both direct or source routed sockets
  // non-zero then opens up the socket to the app

  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ =}
  +                   HEADER_SOURCE_ROUTE                         +   }
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   }
  +            Next Hop (EpochInetSocketAddress)                  +    > // zero or more 
  +                                                               +    >           
  +                                                               +   }           
  +                                                               +   }           
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ =}
  +                      HEADER_DIRECT                            +   
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   
  +                          AppId                                +   
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   
  +                                                               + 
  +                  <Application Stream>                         + 
  +                                                               + 
  +                           ...                                 + 

Here I discuss the protocol for AppId 0 The Normal Pastry socket.  

The Application stream is broken up into Messages.

Each message has the following:
payload size (int): The size of the rest of the message, including the rest of the header, but not the size itself  
address (int) : the application in the Overlay that the message goes to
type (short): the type of message (application dependent)
  however type 0 is reserved for Java Serialized (or platform dependent) messages
Sender (NodeHandle) This parameter is optional
  


/********** Message Header **************/
int payloadSize
int address
boolean hasSender
byte priority
short type (app specific)
// if hasSender
  NodeHandle sender // defined in the next section
<Message Contents>  
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
  +           Total Message Size (not including this)             + 
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
  +              Address (which app to send it to)                +  
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
  +   hasSender?  +   priority    +     type (app specific)       +            
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
  +                                                               +            
  +                                                               +            
  +             NodeHandle Sender (if has one)                    +   

  +                                                               +   
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   
  +                                                               + 
  +                    <Message Contents>                         + 
  +                                                               + 
  +                           ...                                 + 

Due to their complexity the rest of the messages are not Word Aligned


/********** Objects ***************/

FreePastry has several Objects that are often sent over the wire, here is their serialization format:  
The version is so fundamental to FreePastry that it is tied to the protocol version defined at the beginning of the stream.

Id: 
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    +   160 Bit (20 byte)                                           +
    +                                                               +
    +                                                               +
    +                                                               +
    +                                                               +
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
NodeId // format inherited from Id (identical)
  
NodeHandle:
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    + Epoch InetSocketAddress                                       +
    +                                                               +           
    +                                                               +           
    +                                                               +           
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    +   Id                                                          +
    +                                                               +
    +                                                               +
    +                                                               +
    +                                                               +
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


Leafset
    So that small LeafSets (who have overlapping nodes) don't waste bandwidth, 
    leafset first defines the NodeHandles to be loaded into an array, then 
    specifies their locations. We do this because
    a NodeHandle takes up a lot more space than the index in the leafset, and 
    it may be in the leafset 1 or 2 times.    
    A leafset consists of a clockwise and counterclockwise "SimilarSet"  If the ring is very small,
    thse values will overlap.
    
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      + byte theSize  +numUniqueHandls+ byte cwSize   + byte ccwSize  +
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      + NodeHandle baseHandle                                         +
                       ...                                             
      +                                                               +
      +                                                               +
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      + NodeHandle 1st                                                +
                       ...                                             
      +                                                               +
      +                                                               +
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                       ...                                             
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      + NodeHandle numUniqueHandls-th                                 +
                       ...                                             
      +                                                               +
      +                                                               +
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      + byte cw 1st   +  cw  2nd      + ...           + ccw 1st       +
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      + ccw 2nd       +  ...          + ...           + ccw Nth       +
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

  byte theSize // the total capacity of the leafset, not including the baseHandle  (usually 24)
  byte numUniqueHandles // the number of NodeHandles to read (in the next step, does not include the baseHandle)
  byte cwSize // the number of elements of the clockwise SimilarSet
  byte ccwSize // the number of elements of the counterclockwise SimilarSet    
  NodeHandle baseHandle
  // iterate numUniqueHandles times
    NodeHandle handle
  // iterate cwSize
    byte handleIndex // in a clockwise direction
  // iterate ccwSize
    byte handleIndex // in a counterclockwise direction
      
RouteSet:
 A set of nodes typically stored in the routing table. The set contains a
 bounded number of the closest node handles. Since proximity value can change
 unpredictably, we don't keep the set in sorted order.

     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     +    maxSize    +    theSize    +    closest    +
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     + NodeHandle 1st                                                +
                      ...                                             
     +                                                               +
     +                                                               +
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                      ...                                             
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     + NodeHandle theSize-th                                         +
                      ...                                             
     +                                                               +
     +                                                               +
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  byte maxSize // the capacity
  byte theSize // the number of elements in this set
  byte closest // the index of the closest node (often useful for routing decisions)
  // iterate theSize times
    NodeHandle entry


    
// the rest of the protocol is not defined with pictures, as many of the elements have 
// complicated iterations or conditions that can be more well expressed in pseudocode than pictures    
// (read: I'm Lazy)

/***************** Higher level objects **********************/
These objects are not used by the "core" pastry protocol, but may be used by applications
IdRange: Represents a contiguous range of Pastry ids.
  Id Clockwise
  Id CounterClockwise
  boolean empty
  
/******************* Route Message ******************/
RoueMessage:
  address: 0xACBDFE17 (Router)
  type: -23525
  use: To route messages using prefix-based-routing.
  package: rice.pastry.routing

  format:
    byte version(0)  
    int subMessageAddress
    Id target
    NodeHandle prevHop
    
    // the internal message:
    boolean hasSender
    byte priority
    short type
    // if hasSender 
      NodeHandle internalSender
    Message internalMsg

/****************** Join Protocol ******************/	      
JoinRequest:
  address: 0xe80c17e8 (Join Protocol)
  type: 2
  use: During bootstrap, to find the nearest node to you in Id Space.
  package: rice.pastry.standard
  
  format:
	  byte version (0)
    byte rtBaseBitLength
    NodeHandle handle
    boolean hasJoinHandle
      NodeHandle joinHandle // if hasJoinHandle
    // the table
    byte lastRow // decremented on a push call
    // the routing table has this many rows: (NodeId bit length)/rtBaseBitLength = 160/4 = 40
    // and this many columns 2^rtBaseBitLength = 2^4=16
		// each entry is a RouteSet
		// for each row
		  boolean hasRow?
		  // if (hasRow) for each column {
		    boolean hasColumn
  		  // if (hasColumn) for each entry {
  		    RouteSet entry
  		  // }
  		// }    
    boolean hasLeafset
		// if (hasLeafset) 
		  LeafSet leafset
          
ConsistentJoinMessage:
  address: 0xe80c17e8 (Join Protocol)
  type: 2
  use: During Join.  To verify that every node in leafset is aware of your existance, and gossip Leafset
  package: rice.pastry.standard
  
  format:
	  byte version (0)
    LeafSet ls
    boolean request
    int numInFailedSet
      NodeHandle failedHandle
      
/************* LeafSet Maintenance **************/
RequestLeafSet:
  address: 0xf921def1 (Leafset Protocol)
  type: 1
  use: Leafset Maintenance
  package: rice.pastry.leafset

  format: 
		byte version (0)
      
BroadcastLeafSet:
  address: 0xf921def1 (Leafset Protocol)
  type: 2
  use: Leafset Maintenance
  package: rice.pastry.leafset

  format:
	  byte version (0)
	  NodeHandle fromNode
	  LeafSet leafSet
	  int theType

/*************** Routing Table Maintenance **************/	    
RequestRouteRow:
  address: 0x89ce110e (Route Protocol)
  type: 1
  use: Routing Table Maintenance
  package: rice.pastry.routing

  format: 
		byte version (0)
		byte row // the row requested
		
BroadcastRouteRow:
  address: 0x89ce110e (Route Protocol)
  type: 2
  use: Routing Table Maintenance
  package rice.pastry.routing
    
  format:
	  byte version (0)
	  NodeHandle fromNode  
	  byte numRows
	    byte null? (0 if null, 1 if non-null)
	      RouteSet row // if non-null

/*************** CommonAPI impl ***************/
PastryEndpointMessage:
  address: taken from the underlieing endpoint
  type: 2
  use: Adapt a CommonAPI message to FreePastry (Adds an address) wraps the message
  package: rice.pastry.commonapi
  
  format:
    byte priority
    short type (the type of the sub message)
    CommonAPIMessage message
    
/*************** Transport Layer Messages ****************/
These are messages used internal to the transport layer, for all of them the address is 0
    
/*************** Bootstrapping Messages ******************/
LeafSetRequestMessage:
  type: 4
  use: request a LeafSet from a node
  format:
	  byte version (0)

LeafSetResponseMessage:
  type: 5
  use: respond to a LeafSetRequest
  format:
	  byte version (0)
	  LeafSet leafset

NodeIdRequestMessage:
  type: 6
  use: request a NodeId from a node
  format:
	  byte version (0)

NodeIdResponseMessage:
  type: 7
  use: respond to a NodeIdRequest
  format:
	  byte version (0)
		NodeId nodeId
		long epoch
	  
RouteRowRequestMessage:
  type: 10
  use: request a Row from a Routing Table
  format:
	  byte version (0)
	  int row (the row requested)

RouteRowResponseMessage:
  type: 11
  use: respond to a RouteRowRequest
  format:
	  byte version (0)
		// encoding a sparse array
		int numRouteSets
		// for each routeSet
		  boolean notNull
		  // if (notNull)
		    RouteSet set
		    
RoutesRequestMessage:
  type: 12
  use: request SourceRoutes from another node
  format:
	  byte version (0)

RoutesResponseMessage:
  type: 13
  use: respond to a RoutesRequest
  format:
	  byte version (0)
		int numRoutes
		// for each route
      SourceRoute sourceRoute
		    
SourceRoute:
  // source route is a Message type for convienience (otherwise we'd have to have special headers and stuff)  Sometimes the protocol just sends a SourceRoute	  	  
	type: 1
	use: Holds a SourceRoute
  format:
	  byte version (0)
		int numInPath
		// for each hop
		  EpochInetSocketAddress address

/************ UDP Messages ***************/
For Liveness and NAT (Network Address Translator) handling
Note that this doesn't make NAT traversal automatic, but just allows FreePastry to detect the external address, port forwarding must be set up

The format of these messages is a bit different because they are UDP and need to carry source route info at each step:	
Header:

// Magic Number
byte[4] PASTRY_MAGIC_NUMBER = {0x27, 0x40, 0x75, 0x3A}
		
// Protocol Version (0) for now, but this may become more interesting in the future, such as being in part, a bitwise selection
int 0

{0x49, 0x3A, 0x09, 0x5C}	  			      
byte 1 // the current hop counter (incremented at each step)
byte numHops // for source routing
EpochInetSocketAddress localAddress
// for each hop
  EpochInetSocketAddress hop

    