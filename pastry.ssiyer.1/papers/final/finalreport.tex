\documentclass{article}

\usepackage{algorithm}
\usepackage{algorithmic}

\usepackage{psfrag,psfig,epsfig,epsf}
\usepackage{graphics}

\title{Free Pastry Implementation Report}
\author{Andrew Ladd\\ {\tt aladd@cs.rice.edu}}

\begin{document}
\maketitle

\begin{abstract}
Pastry is a peer-to-peer network routing protocol.  It features
routing depth which is logarithmic in the number of nodes in the
network and fault tolerance even in the presence of byzantine nodes and
arbitrary node failure.  This document describes an implementation of
Pastry which is free.  The emphasis of the implementation is on
simplicity and documention.  The widespread distribution of such an
implementation is instrumental in the adoption of Pastry as a
peer-to-peer standard.
\end{abstract}

\section{Introduction}

This is document is meant to be a high level view of the Free Pastry
implementation and should be read before the source level
documentation or the source code is examined.  This document features

\begin{itemize}
\item the Pastry API.
\item the architecture.
\item the principal data structures.
\item the routing algorithm as it is currently
  implemented.
\item the leaf set protocol as it is currently
  implemented.
\item the join protocol as it is currently
  implemented.
\end{itemize}

The implementation we provide is designed in the message passing
paradigm.  There are two levels of addressing: each Pastry node is
identified with a unique node id and at each node has components that
have their own addresses.  Each message has an address.  There is a
distinguished route message and address, the router address.  The
router is bound to the router address and receives route messages
which are sent to remote nodes according to the routing algorithm. When
the node with the most similar node id to the target node id in the
route message, the internal message is delivered.

Pastry clients interface with the exported API and register with the
Pastry node.  Security is handled in an extensible way by the
credentials which verify the various bindings as well as certifying
authenticity of messages.

Tolerance against node failure is implemented by maintaining the data
structures lazily as they are used.  Tolerance against byzantine nodes
can be implemented by extending the leaf set maintanence algorithm.

\subsection{Details}

The implementation was done in {\tt Java 1.31SE}.  The source level
documentation was done with {\tt Javadoc}.

\section{Pastry API}
\subsection{Pastry Node}

A Pastry node is polymorphically a node handle and message receiver.
It has the following API methods:

\begin{description}

\item [getNodeId()] returns the node id of the Pastry node.
\item [addLeafSetObserver(Observer o)] adds an observer which will be
  notified of changes to leaf set.
\item [addRouteSetObserver(Observer o)] add an observer which will be
  notified of changes to the routing table.
\item [receiveMessage(Message msg)] receives a message from the remote
  world.
\item [registerReceiver(Credentials cred, Address addr, MessageReceiver mr)] registers a message
  receiver with the Pastry node at the given address.   This binding
  is witnessed by the supplied credentials.
\item [registerClient(PastryClient pc)] attaches a Pastry client to the node.

\end{description}

\subsection{Pastry Client}

A Pastry client is an external message receiver which is a default
interface to a Pastry node.  All of its functionality is availible
through the Pastry node in a more awkward way.

\begin{description}

\item [getNodeId()] gets the node id associated with the client.
\item [registerReceiver(Credentials cred, Address addr,
  MessageReceiver mr)] registers a message receiver with the Pastry
  node.
\item [sendMessage(Message msg)] sends a message to the local Pastry
  node.
\item [routeMessage(NodeId target, Message msg, Credentials cred,
  SendOptions opt)] sends a message to the node with the node id
  most similar to taregt.
\item [sendEnrouteMessage(NodeId target, Message msg, Credentials cred,
  SendOptions opt)] sends a message to the ndoe with the node id
  most similar to target except at each hop the message delivered
  locally to the address of this client.
\end{description}

The following are abstract methods that client overrides:

\begin{description}

\item [getAddress()] gets the address of this client.
\item [getCredentials()] gets the credentials of this client.
\item [messageForClient(Message msg)] called by Pastry when a message
  for the cl

\end{description}

\section{Architecture}

\section{Data Structures}\label{section:ds}
Data structures are in our implementation are self-maintaining and
observable.  Observers are notified of changes to the data structures.

\subsection{Route Set}

A route set is a set of node handles.  The maximum size of a route set
is fixed and the closest nodes are kept.  The usual set operations are
supported.  Currently the nodes are not maintained in sorted order
although they could be.

\subsection{Routing Table}

A routing table is $2$-d of route sets.  The rows correspond to digits
in the node id and the columns correspond to digit values.  The
routing table contains gaps at the entries which correspond to it own
node id.  Each node id corresponds to a unique lookup in the table
based on its most significant differing digit index and value.  The
route set at entry contains nodes that correspond to that entry.

\subsection{Leaf Set}

The leaf set is a fixed size set of the most similar clockwise and
counterclockwise nodes.  The leaf set is maintained in sorted order on
both sides.
\section{Routing Algorithm}

The routing algorithm was implemented as in algorithm \ref{alg:route}.

\begin{algorithm}[t]
\caption{ROUTE({\tt M})}
\label{alg:route}
\begin{algorithmic}
\IF {{\tt M.target} equals the local node id}
\STATE deliver {\tt M} locally.
\ELSE

\IF {{\tt M.target} within the bounds of the leaf set}

\IF {{\tt M.target} is most similar to the local node id}
\STATE deliver {\tt M} locally.
\ELSE
\STATE deliver to closest node in the leaf set.
\ENDIF

\ELSE
\STATE let {\tt RS} be the route set at the entry corresponding to
       {\tt M.target}.
\IF {{\tt RS} is empty}
\STATE deliver to most similar leaf set node.
\ELSE
\STATE deliver to a node from {\tt RS}.
\ENDIF
\ENDIF
\ENDIF
\end{algorithmic}
\end{algorithm}

\section{Leaf Set Protocol}

The leaf set protocol deals with two message types : 

\begin{enumerate}

\item broadcasts of leaf sets and
\item request for leaf sets.  

\end{enumerate}

Requests are handled by broadcasting the leaf set to the node that
made the request.  

When a broadcast is received, all the node handles in the set are put
into the leafset.

The leaf set protocol is also an observer for leaf set changes.
When a node is added, the local node broadcasts its leaf set to the
added node and requests its leaf set.  
When a node is removed, the leaf set of the extreme node in the leaf
set is requested.

\section{Join Protocol}

The join protocol inductively constructs a valid Pastry network.
When a new node wishes to join the following occurs:

\begin{enumerate}

\item A message is sent to the node in the existing network with the
  most similar node id to the new node.
\item At each hop in the route, the appropriate rows from the routing
  table are gathered.
\item At the destination, the new node is added to the leaf set of the
  destination node and the message is stamped accepted with a node
  handle for the destination node.
\item The message is then sent directly back to the new node.
\item The new node constructs it routing table.
\item The constructed routing table is broadcast row by row to the
  appropriate nodes in the table.

\end{enumerate}

The leaf set protocol implicitly takes care of constructing the leaf set.

\section{Test Framework}

Testing was executed by constructing networks of various sizes and
verifying that the pings follow reasonable routes and arrive at the
correct destination.   Figure \ref{fig:message} shows a graph of
network size versus the number of messages sent per hundred nodes.

Complete code coverage was verified, however the network is totally
sequential (messages are sent FIFO) and there may be an
undiscovered bug resulting from reasonable interleaving of messages.

Extensions to the network simulator are warranted and should be made.

\begin{figure}[t]
\centerline{\psfig{figure=msgs.ps,height=4.5cm}}
\caption{Network versus messages sent per hundred nodes}
\label{fig:message}
\end{figure}

\section{Glossary}

\begin{description}

\item [address] addresses are bound to {\bf message receivers} by the
  {\bf message dispatch}.

\item [broadcast] a {\bf message} which is a sent to a set of {\bf
  Pastry nodes} containing a datagram.

\item [client] a {\bf message receiver} which is an external to the
  {\bf Pastry node} and interacts through the {\bf Pastry API}.

\item [clockwise] {\bf node ids} can be visualized as being
  distributed on a circle.  A {\bf node id} $b$ is clockwise from {\bf
  node id} $a$ if the shortest path on the circle from $a$ to $b$ is
  clockwise.

\item [close] said of distance between two {\bf Pastry nodes} in terms of an
  estimate of the cost to send a message.

\item [credentials] a proof of authenticity verifying the various
  bindings that are used in {\bf Pastry}.

\item [enroute] a {\bf route message} which has a supplied auxilary
  {\bf address}.  At each hop, the internal {\bf message} is delivered
  to the {\bf address}.  The {\bf route message} can be optionally
  routed by the {\bf message receiver} that receives it. 

\item [leaf set] maintained at each {\bf Pastry node}, it is a fixed
  size set of {\bf similar} {\bf node handles}.  This is described in
  section \ref{section:ds}.

\item [leaf set protocol] maintains the properties of the {\bf leaf set}
  through communication.

\item [join protocol] a protocol that governs how a new {\bf Pastry
  node} joins the network.

\item [message] a datagram marked with a destination {\bf address} and
  {\bf credentials} certifying the authenticity of the message.

\item [message dispatch] a map of binding {\bf addresses} to {\bf
  message receivers}.  This binding is witnessed by {\bf credentials}.

\item [message receiver] any object capable of acting as destination
  for a {\bf message}.  These objects are the internal {\bf Pastry}
  components as well as the {\bf clients}.

\item [node handle] a local interface to an abstract {\bf message receiver} for a {\bf
  Pastry node} with a given {\bf node id}.

\item [node id] a bit string which acts as the unique identifier of a
  {\bf Pastry node}.

\item [node id factory] an interface to an object which is used to
  create {\bf node ids}.

\item [Pastry] a routing protocol for a peer-to-peer network.

\item [Pastry API] an exported programmer interface to a {\bf Pastry} node.

\item [Pastry node] a single node in a {\bf Pastry} network.

\item [Pastry node factory] an interface to an object which is used to create {\bf
  Pastry nodes}.

\item [request] a request for some data to be returned through a
  supplied {\bf node handle}.

\item [route message] a wrapper a {\bf message} which is destined for
  a supplied {\bf node id}.

\item [router] a {\bf message receiver} which receives {\bf route
  messages} and redirects them appropriately.

\item [route row] a row from the {\bf routing table}, this row
  corresponds to digits of the {\bf node id}.

\item [route set] a set of {\bf node handles} at an individual entry
  in the {\bf routing table}, favouring {\bf nodes} that are {\bf close}.

\item [routing table] a $3$-d table of {\bf node handles} maintained
  at each {\bf Pastry node}. For use with the {\bf router}, this is described in
  section \ref{section:ds}.

\item [security manager] an interface to piece of code which verifies
  bindings in {\bf Pastry}.

\item [similar] said of two {\bf node ids} with numerical similar {\bf
  node ids}.

\item [target node id] the {\bf node id} that {\bf route message} is
  to be sent to.

\end{description}

\end{document}